//////////////////////////////////////////////////////////////////////////////
//   ____  ____
//  /   /\/   /
// /___/  \  /    Vendor: Xilinx
// \   \   \/     Version : 1.7
//  \   \         Application : Xilinx GTX Wizard
//  /   /         Filename : CC_2B_1SKP.v
// /___/   /\
// \   \  /  \
//  \___\/\___\
//
//
// Module CC_2B_1SKP
// Generated by Xilinx GTX Transceiver Wizard
//
//
// (c) Copyright 2008 - 2009 Xilinx, Inc. All rights reserved.
//
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
//
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
//
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
//
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.


`timescale 1 ns / 10 ps
`ifdef DLY
`else
    `define DLY #1
`endif

module  CC_2B_1SKP #(
    parameter   CC_CHAR = 8'h1C,                // CC character
    parameter   ALIGN_CHAR = 8'h7C,             // Align status character
    parameter   CHAN_BOND_MODE = "OFF",         // "OFF", "MASTER", "SLAVE"
    parameter   ALIGN_PARALLEL_CHECK = 1'b1,    // Check align in parallel data
    parameter   USE_AUTORECOVER = 1'b1,         // Reserved. Always ON.
    parameter   FIFO_ALMOST_EMPTY_OFFSET = 5,
    parameter   FIFO_ALMOST_FULL_OFFSET  = 498
)
(
    // Write Interface on the GT_RXUSRCLK2
    input       [15:0]  GT_RXDATA,
    input       [1:0]   GT_RXCHARISK,
    input       [1:0]   GT_RXCHARISCOMMA,
    input       [1:0]   GT_RXRUNDISP,
    input       [1:0]   GT_RXNOTINTABLE,
    input       [1:0]   GT_RXDISPERR,
    input       [2:0]   GT_RXBUFSTATUS,
    input       [2:0]   GT_RXCLKCORCNT,
    input               GT_RXCHANBONDSEQ,
    input               GT_RXCHANISALIGNED,
    input               GT_RXCHANREALIGN,
    input       [1:0]   GT_RXLOSSOFSYNC,
    input               GT_RXVALID,
    input               GT_RXUSRCLK2,

    // Read Interface on the USER_RXUSRCLK2
    output      [15:0]  USER_RXDATA,
    output      [1:0]   USER_RXCHARISK,
    output      [1:0]   USER_RXCHARISCOMMA,
    output      [1:0]   USER_RXRUNDISP,
    output      [1:0]   USER_RXNOTINTABLE,
    output      [1:0]   USER_RXDISPERR,
    output      [2:0]   USER_RXBUFSTATUS,
    output      [2:0]   USER_RXCLKCORCNT,
    output              USER_RXCHANBONDSEQ,
    output              USER_RXCHANISALIGNED,
    output              USER_RXCHANREALIGN,
    output      [1:0]   USER_RXLOSSOFSYNC,
    output              USER_RXVALID,
    input               USER_RXUSRCLK2,

    // Status and reset signals
    input               RESET,
    input       [6:0]   CCI, // Input for the slave
    output      [6:0]   CCO  // Output from the master
                             // Bit 0-AE. Bit 1-RRESET. Bit 2-AF.
                             // Bit 3-WRESET. Bit 4 - Status Lower B.
                             // Bit 5 - Status Upper. Bit 6-AE level.
);

//********************** Wire Declarations ***********************************

    // Write side datapath and CC match location
    wire  [13:0]      lower_gt_data_c;
    wire  [13:0]      upper_gt_data_c;
    wire  [1:0]       write_mux_0_i;
    wire  [1:0]       write_mux_1_i;
    wire  [35:0]      write_data_fifo_i;
    wire  [1:0]       write_cc_location_i;
    wire              deleted_cc_i;

    // Write side FIFO
    wire              almost_full_i;
    wire              wfsm_mailbox_overflow_i;
    wire              wr_en_i;
    wire              wr_err_i;
    wire              wfsm_idle_i;

    // Read side datapath and CC match location
    wire  [13:0]      lower_user_data_i;
    wire  [13:0]      upper_user_data_i;
    wire  [1:0]       read_mux_0_i;
    wire  [1:0]       read_mux_1_i;
    wire  [35:0]      read_data_fifo_i;
    wire  [1:0]       read_cc_location_i;
    wire              inserted_cc_i;
    wire              user_rxchanisaligned_i;
    wire              user_rxchanrealign_i;
    wire  [1:0]       user_rxlossofsync_i;
    wire              user_rxvalid_i;

    // Read side FIFO
    wire              almost_empty_i;
    wire              rfsm_mailbox_overflow_i;
    wire              rd_en_i;
    wire              rd_err_i;
    wire              rfsm_idle_i;

    // Status
    wire  [2:0]       user_rxbufstatus_c;
    wire  [2:0]       user_rxclkcorcnt_c;



//******************************* Register Declarations **********************

    // Reset signals

    // synthesis attribute shreg_extract of reset_rxrecclk_r is no
    // synthesis attribute shreg_extract of reset_rxusrclk2_r is no

    // Modified by James to workaround timing issue
    reg   [3:0]       reset_rxrecclk_r  = 4'b1111 /* synthesis syn_srlstyle = "registers" syn_maxfan = 10*/ ;
    reg   [3:0]       reset_rxusrclk2_r = 4'b1111 /* synthesis syn_srlstyle = "registers" syn_maxfan = 10*/ ;

         // Write side datapath and CC match location
    reg               inserted_cc_r;
    reg               gt_rxchanisaligned_r;
    reg               gt_rxchanrealign_r;
    reg   [1:0]       gt_rxlossofsync_r;
    reg               gt_rxvalid_r;

    // Write side FIFO
    reg               wr_err_rxrecclk_domain_r;
    reg               wr_err_r;
    reg               wr_err_r2;

    // Read side datapath and CC match location
    reg               deleted_cc_r;
    reg               user_rxchanisaligned_r;
    reg               user_rxchanrealign_r;
    reg   [1:0]       user_rxlossofsync_r;
    reg               user_rxvalid_r;

    // Status
    reg   [2:0]       user_rxbufstatus_r;
    reg   [2:0]       user_rxclkcorcnt_r;

    //FIFO Flags registers
    reg               almost_empty_r;
    reg               almost_empty_r2;
    reg               almost_empty_r3;
    reg               almost_full_r;
    reg               almost_full_r2;
    reg               almost_full_r3;

    // Align status registers
    reg               upper_user_data_status_r;
    reg               lower_user_data_status_r;
    reg               user_align_status_r;

    // synthesis attribute ASYNC_REG of wr_err_r is "TRUE";
    // synthesis attribute ASYNC_REG of wr_err_r2 is "TRUE";
    // synthesis attribute ASYNC_REG of almost_empty_r is "TRUE";
    // synthesis attribute ASYNC_REG of almost_empty_r2 is "TRUE";
    // synthesis attribute ASYNC_REG of almost_empty_r3 is "TRUE";
    // synthesis attribute ASYNC_REG of upper_user_data_status_r is "TRUE";
    // synthesis attribute ASYNC_REG of lower_user_data_status_r is "TRUE";
    // synthesis attribute ASYNC_REG of user_align_status_r is "TRUE";
    // synthesis attribute ASYNC_REG of user_rxchanisaligned_r is "TRUE";
    // synthesis attribute ASYNC_REG of user_rxlossofsync_r is "TRUE";
    // synthesis attribute ASYNC_REG of user_rxvalid_r is "TRUE";
    // synthesis attribute ASYNC_REG of user_rxbufstatus_r is "TRUE";
    // synthesis attribute ASYNC_REG of inserted_cc_r is "TRUE";
    // synthesis attribute ASYNC_REG of deleted_cc_r is "TRUE";
    // synthesis attribute ASYNC_REG of user_rxclkcorcnt_r is "TRUE";
    // synthesis attribute ASYNC_REG of almost_full_r is "TRUE";
    // synthesis attribute ASYNC_REG of almost_full_r2 is "TRUE";
    // synthesis attribute ASYNC_REG of almost_full_r3 is "TRUE";
    // synthesis attribute ASYNC_REG of gt_rxchanisaligned_r is "TRUE";
    // synthesis attribute ASYNC_REG of gt_rxchanrealign_r is "TRUE";
    // synthesis attribute ASYNC_REG of gt_rxlossofsync_r is "TRUE";
    // synthesis attribute ASYNC_REG of gt_rxvalid_r is "TRUE";
    // synthesis attribute ASYNC_REG of wr_err_rxrecclk_domain_r is "TRUE";
    // synthesis attribute ASYNC_REG of reset_rxusrclk2_r is "TRUE";
    // synthesis attribute ASYNC_REG of reset_rxrecclk_r is "TRUE";
    
//********************** Main Body of Code ***********************************

    //__________ Defining Master & Slave for resets __________________________
    generate
        if (CHAN_BOND_MODE == "OFF" || CHAN_BOND_MODE == "MASTER")
        begin : generate_reset

            assign CCO[1] = reset_rxusrclk2_r[0];
            assign CCO[3] = reset_rxrecclk_r[0];

            // Synchronize reset to GT_RXUSRCLK2
            // Making it 3 clock cycles long to keep it in sync with
            // the reset based on USER_RXUSRCLK2
            always @(posedge GT_RXUSRCLK2 or posedge reset_rxusrclk2_r[0])
            if (reset_rxusrclk2_r[0])
                reset_rxrecclk_r <= `DLY 4'b1111;
            else
                reset_rxrecclk_r <= `DLY {1'b0, reset_rxrecclk_r[3:1]};

            // Synchronize reset to USER_RXUSRCLK2
            // The reset register for the USER_RXUSRCLK2 is 3 bits wide because
            // the RESET of the FIFO36 needs to be asserted for three clock
            // cycles long
            always @(posedge USER_RXUSRCLK2 or posedge RESET)
            if (RESET)
                reset_rxusrclk2_r <= `DLY 4'b1111;
            else
                reset_rxusrclk2_r <= `DLY {1'b0, reset_rxusrclk2_r[3:1]};
        end
        else if (CHAN_BOND_MODE == "SLAVE")
        begin : generate_slave_reset
            always @(CCI[3])
              reset_rxrecclk_r[0] = CCI[3];

            always @(CCI[1])
              reset_rxusrclk2_r[0] = CCI[1];
        end
    endgenerate

    //__________ Defining Master & Slave for USE_AUTORECOVER _________________
    generate
        if (USE_AUTORECOVER && CHAN_BOND_MODE == "MASTER")
        begin : generate_flag_pulses

            assign CCO[0] = almost_empty_r2;
            assign CCO[2] = almost_full_r2;
            assign CCO[6] = almost_empty_r;

            // Write side
            always@(posedge GT_RXUSRCLK2)
                if(reset_rxrecclk_r[0])
                begin
                    almost_full_r <= `DLY 1'b0;
                    almost_full_r2 <= `DLY 1'b0;
                    almost_full_r3 <= `DLY 1'b0;
                end
                else
                begin
                    almost_full_r <= `DLY almost_full_i;
                    almost_full_r2 <= `DLY (almost_full_r2 ^ almost_full_r3) ?
                                         1'b0 : (almost_full_i & wfsm_idle_i);
                    almost_full_r3 <= `DLY almost_full_r2;
                end

            // Read side
            always@(posedge USER_RXUSRCLK2)
                if(reset_rxusrclk2_r[0])
                begin
                    almost_empty_r <= `DLY 1'b1;
                    almost_empty_r2 <= `DLY 1'b0;
                    almost_empty_r3 <= `DLY 1'b0;
                end
                else
                begin
                    almost_empty_r <= `DLY almost_empty_i;
                    almost_empty_r2 <= `DLY (almost_empty_r2 ^ almost_empty_r3) ?
                                                1'b0 : (almost_empty_i & rfsm_idle_i);
                    almost_empty_r3 <= `DLY almost_empty_r2;
                end
        end

        else if ( (!USE_AUTORECOVER && CHAN_BOND_MODE == "MASTER") || (CHAN_BOND_MODE == "OFF"))
        begin : generate_master_flag_levels
            assign CCO[0] = almost_empty_r2;
            assign CCO[2] = almost_full_r2;

            always @(almost_full_r)
                almost_full_r2 = almost_full_r;

            always @(almost_empty_r)
                almost_empty_r2 = almost_empty_r;

            // Write side
            always@(posedge GT_RXUSRCLK2)
                if(reset_rxrecclk_r[0])
                    almost_full_r <= `DLY 1'b0;
                else
                    almost_full_r <= `DLY almost_full_i;

            // Read side
            always@(posedge USER_RXUSRCLK2)
                if(reset_rxusrclk2_r[0])
                    almost_empty_r <= `DLY 1'b1;
                else
                    almost_empty_r <= `DLY almost_empty_i;
        end

        else if (USE_AUTORECOVER && CHAN_BOND_MODE == "SLAVE")
        begin : generate_slave_flag_pulses
            always @(CCI[2])
                almost_full_r2 = CCI[2];

            always @(CCI[0])
                almost_empty_r2 = CCI[0];

            always @(CCI[6])
                almost_empty_r = CCI[6];
        end

        else if(!USE_AUTORECOVER && CHAN_BOND_MODE == "SLAVE")
        begin : generate_slave_flag_levels
            always @(CCI[2])
                almost_full_r2 = CCI[2];

            always @(CCI[0])
                almost_empty_r = CCI[0];

            always @(almost_empty_r)
                almost_empty_r2 = almost_empty_r;
        end
    endgenerate

    //__________ Defining the align status flag__________________//
    generate
        if (ALIGN_PARALLEL_CHECK && CHAN_BOND_MODE == "MASTER")
        begin : generate_m_align
            assign CCO[5] = upper_user_data_status_r;
            assign CCO[4] = lower_user_data_status_r;
            assign USER_RXCHANISALIGNED = user_rxchanisaligned_r;

            //Upper and Lower Data byte
            always@ (posedge USER_RXUSRCLK2)
                if (reset_rxusrclk2_r[0]) begin
                    upper_user_data_status_r <= `DLY 1'b0;
                    lower_user_data_status_r <= `DLY 1'b0;
                end
                else begin
                    upper_user_data_status_r <= `DLY (upper_user_data_i[8:0] == {1'b1,ALIGN_CHAR}) ? 1'b1 : 1'b0;
                    lower_user_data_status_r <= `DLY (lower_user_data_i[8:0] == {1'b1,ALIGN_CHAR}) ? 1'b1 : 1'b0;
                end
        end

        else if (ALIGN_PARALLEL_CHECK && CHAN_BOND_MODE == "SLAVE")
        begin : generate_s_align
            assign USER_RXCHANISALIGNED = user_align_status_r;

            assign align_status_i = ( ((CCI[5] ^~ upper_user_data_status_r ) &&
                                      (CCI[4] ^~ lower_user_data_status_r))  &&
                                      user_rxchanisaligned_r);

            //Upper and Lower Data byte
            always@ (posedge USER_RXUSRCLK2)
                if (reset_rxusrclk2_r[0]) begin
                    upper_user_data_status_r <= `DLY 1'b0;
                    lower_user_data_status_r <= `DLY 1'b0;
                end
                else begin
                    upper_user_data_status_r <= `DLY (upper_user_data_i[8:0] == {1'b1,ALIGN_CHAR}) ? 1'b1 : 1'b0;
                    lower_user_data_status_r <= `DLY (lower_user_data_i[8:0] == {1'b1,ALIGN_CHAR}) ? 1'b1 : 1'b0;
                end

            always@ (posedge USER_RXUSRCLK2)
                if (reset_rxusrclk2_r[0])
                      user_align_status_r <= `DLY 1'b0;
                else if (CCI[4] | CCI[5] | upper_user_data_status_r |
                         lower_user_data_status_r | ~user_rxchanisaligned_r)
                      user_align_status_r <= align_status_i;
                else
                      user_align_status_r <= user_align_status_r;

        end
        else
        begin : generate_off_align
            assign USER_RXCHANISALIGNED = user_rxchanisaligned_r;
        end
    endgenerate

    //_________________ Logic for writing to the elastic buffer ______________

    // Combine incoming GT data and control signals into the lower and upper
    // portions of the word.  There are 16 bits of data and control in the
    // upper and lower locations of the word.
    //
    // The modules below do the following when the GT_RXUSRCLK2 is faster than
    // the USER_RXUSRCLK2:
    // - Find the CC sequence in the data path and mark it whenever the
    //   FIFO becomes full
    // - Generate control signals to the FIFO
    // - Select the appropriate lower or upper portions of the word in the
    //   datapath whenever a CC sequence is deleted
    assign lower_gt_data_c  = {
                                  GT_RXCHANBONDSEQ,     // [13]
                                  GT_RXDISPERR[0],      // [12]
                                  GT_RXNOTINTABLE[0],   // [11]
                                  GT_RXRUNDISP[0],      // [10]
                                  GT_RXCHARISCOMMA[0],  // [9]
                                  GT_RXCHARISK[0],      // [8]
                                  GT_RXDATA[7:0]        // [7:0]
                                  };

    assign upper_gt_data_c  = {
                                  GT_RXCHANBONDSEQ,     // [13]
                                  GT_RXDISPERR[1],      // [12]
                                  GT_RXNOTINTABLE[1],   // [11]
                                  GT_RXRUNDISP[1],      // [10]
                                  GT_RXCHARISCOMMA[1],  // [9]
                                  GT_RXCHARISK[1],      // [8]
                                  GT_RXDATA[15:8]       // [7:0]
                                  };

    // Instantiate the datapath for the write side
    CC_2B_1SKP_DATA_PATH write_data_path_i
    (
        .CLK(GT_RXUSRCLK2),
        .DATA_IN({upper_gt_data_c, lower_gt_data_c}),
        .SEL_0(write_mux_0_i),
        .SEL_1(write_mux_1_i),
        .RST(reset_rxrecclk_r[0]),
        .DATA_OUT(write_data_fifo_i[27:0])
    );

    // Synchronize the RXCHANISALIGNED signal and pipe it through the FIFO
    always @(posedge GT_RXUSRCLK2)
        if (reset_rxrecclk_r[0])
            gt_rxchanisaligned_r <= `DLY 1'b0;
        else
            gt_rxchanisaligned_r <= `DLY GT_RXCHANISALIGNED;

    assign write_data_fifo_i[28] = gt_rxchanisaligned_r;

    // Synchronize the RXCHANREALIGN signal and pipe it through the FIFO
    always @(posedge GT_RXUSRCLK2)
        if (reset_rxrecclk_r[0])
            gt_rxchanrealign_r <= `DLY 1'b0;
        else
            gt_rxchanrealign_r <= `DLY GT_RXCHANREALIGN;

    assign write_data_fifo_i[29] = gt_rxchanrealign_r;

    // Synchronize the RXLOSSOFSYNC[1:0] signal and pipe it through the FIFO
    always @(posedge GT_RXUSRCLK2)
        if (reset_rxrecclk_r[0])
            gt_rxlossofsync_r[1:0] <= `DLY 2'b00;
        else
            gt_rxlossofsync_r[1:0] <= `DLY GT_RXLOSSOFSYNC[1:0];

    assign write_data_fifo_i[31:30] = gt_rxlossofsync_r[1:0];

    // Pipe the RXBUFSTATUS signal through the FIFO to the USER_RXUSRCLK2 domain
    assign write_data_fifo_i[32] = GT_RXBUFSTATUS[2];

    // Pipe the DELETED_CC indicator through the FIFO to the USER_RXUSRCLK2 domain
    assign write_data_fifo_i[33] = deleted_cc_i;

    // Synchronize the RXVALID signal and pipe it through the FIFO
    always @(posedge GT_RXUSRCLK2)
        if (reset_rxrecclk_r[0])
            gt_rxvalid_r <= `DLY 1'b0;
        else
            gt_rxvalid_r <= `DLY GT_RXVALID;

    assign write_data_fifo_i[34] = gt_rxvalid_r;

    // Tied the remaining bits of the FIFO to ground
    assign write_data_fifo_i[35] = 1'b0;

    // Instantiate the pattern match for the write side for detecting
    // a CC sequence
    CC_2B_1SKP_PATTERN_MATCH #(
        .CC_CHAR (CC_CHAR)
    )
    write_pattern_match_i
    (
        .DATA_IN({upper_gt_data_c, lower_gt_data_c}),
        .DATA_OUT(write_cc_location_i)
    );

    // Instantiate the FSM for the write side
    CC_2B_1SKP_WFSM #(
        .USE_AUTORECOVER (USE_AUTORECOVER)
    )
    write_fsm_i
    (
        .USER_CLK(GT_RXUSRCLK2),
        .RESET(reset_rxrecclk_r[0]),
        .BYTE_STATUS(write_cc_location_i),
        .AF_STATUS(almost_full_r2),
        .SEL_0(write_mux_0_i),
        .SEL_1(write_mux_1_i),
        .WEN(wr_en_i),
        .WFSM_IDLE(wfsm_idle_i),
        .DELETED_CC(deleted_cc_i),
        .MAILBOX_OVERFLOW(wfsm_mailbox_overflow_i)
    );


    //___________________________ Logic for Buffer Read interface ____________

    // Split the lower and upper portions of the word into individual signals
    //
    // The modules below do the following when the GT_RXUSRCLK2 is slower than
    // the USER_RXUSRCLK2:
    // - Find the CC sequence in the data path and mark it whenever the
    //   FIFO becomes empty
    // - Generate control signals to the FIFO
    // - Select the appropriate lower or upper portions of the word in the
    //   datapath whenever a CC sequence is added
    assign USER_RXCHANBONDSEQ = upper_user_data_i[13] | lower_user_data_i[13];
    assign USER_RXDISPERR = {upper_user_data_i[12], lower_user_data_i[12]};
    assign USER_RXNOTINTABLE = {upper_user_data_i[11], lower_user_data_i[11]};
    assign USER_RXRUNDISP = {upper_user_data_i[10], lower_user_data_i[10]};
    assign USER_RXCHARISCOMMA = {upper_user_data_i[9], lower_user_data_i[9]};
    assign USER_RXCHARISK = {upper_user_data_i[8], lower_user_data_i[8]};
    assign USER_RXDATA = {upper_user_data_i[7:0], lower_user_data_i[7:0]};

    // Delay the RXCHANISALIGNED piped from the FIFO going into the SRL16 by
    // 4 clock cycles.  A FF is added after the SRL16 before going to the user
    // which will delay the signal by 6 clock cycles (this includes the FF
    // before the FIFO).
    SRL16 srl16_user_rxchanisaligned_i
    (
        .Q    (user_rxchanisaligned_i),
        .A0   (1'b1),
        .A1   (1'b1),
        .A2   (1'b0),
        .A3   (1'b0),
        .CLK  (USER_RXUSRCLK2),
        .D    (read_data_fifo_i[28])
    );

    always @(posedge USER_RXUSRCLK2)
        if (reset_rxusrclk2_r[0])
            user_rxchanisaligned_r <= `DLY 1'b0;
        else
            user_rxchanisaligned_r <= `DLY user_rxchanisaligned_i;

    // Delay the RXCHANREALIGN piped from the FIFO going into the SRL16 by
    // 4 clock cycles.  A FF is added after the SRL16 before going to the user
    // which will delay the signal by 6 clock cycles (this includes the FF
    // before the FIFO).
    SRL16 srl16_user_rxchanrealign_i
    (
        .Q    (user_rxchanrealign_i),
        .A0   (1'b1),
        .A1   (1'b1),
        .A2   (1'b0),
        .A3   (1'b0),
        .CLK  (USER_RXUSRCLK2),
        .D    (read_data_fifo_i[29])
    );

    always @(posedge USER_RXUSRCLK2)
        if (reset_rxusrclk2_r[0])
            user_rxchanrealign_r <= `DLY 1'b0;
        else
            user_rxchanrealign_r <= `DLY user_rxchanrealign_i;

    assign USER_RXCHANREALIGN = user_rxchanrealign_r;

    // Delay the RXLOSSOFSYNC[1:0] piped from the FIFO going into the SRL16 by
    // 4 clock cycles.  A FF is added after the SRL16 before going to the user
    // which will delay the signal by 6 clock cycles (this includes the FF
    // before the FIFO).
    SRL16 srl16_user_rxlossofsync0_i
    (
        .Q    (user_rxlossofsync_i[0]),
        .A0   (1'b1),
        .A1   (1'b1),
        .A2   (1'b0),
        .A3   (1'b0),
        .CLK  (USER_RXUSRCLK2),
        .D    (read_data_fifo_i[30])
    );

    SRL16 srl16_user_rxlossofsync1_i
    (
        .Q    (user_rxlossofsync_i[1]),
        .A0   (1'b1),
        .A1   (1'b1),
        .A2   (1'b0),
        .A3   (1'b0),
        .CLK  (USER_RXUSRCLK2),
        .D    (read_data_fifo_i[31])
    );

    always @(posedge USER_RXUSRCLK2)
        if (reset_rxusrclk2_r[0])
            user_rxlossofsync_r[1:0] <= `DLY 2'b00;
        else
            user_rxlossofsync_r[1:0] <= `DLY user_rxlossofsync_i[1:0];

    assign USER_RXLOSSOFSYNC[1:0] = user_rxlossofsync_r[1:0];

    // Delay the RXVALID piped from the FIFO going into the SRL16 by
    // 4 clock cycles.  A FF is added after the SRL16 before going to the user
    // which will delay the signal by 6 clock cycles (this includes the FF
    // before the FIFO).
    SRL16 srl16_user_rxvalid_i
    (
        .Q    (user_rxvalid_i),
        .A0   (1'b1),
        .A1   (1'b1),
        .A2   (1'b0),
        .A3   (1'b0),
        .CLK  (USER_RXUSRCLK2),
        .D    (read_data_fifo_i[34])
    );

    always @(posedge USER_RXUSRCLK2)
        if (reset_rxusrclk2_r[0])
            user_rxvalid_r <= `DLY 1'b0;
        else
            user_rxvalid_r <= `DLY user_rxvalid_i;

    assign USER_RXVALID = user_rxvalid_r;

    // Instantiate the datapath for the read side
    CC_2B_1SKP_DATA_PATH read_data_path_i
    (
        .CLK(USER_RXUSRCLK2),
        .DATA_IN(read_data_fifo_i[27:0]),
        .SEL_0(read_mux_0_i),
        .SEL_1(read_mux_1_i),
        .RST(reset_rxusrclk2_r[0]),
        .DATA_OUT({upper_user_data_i, lower_user_data_i})
    );

    // Instantiate the pattern match for the read side for detecting
    // a CC sequence
    CC_2B_1SKP_PATTERN_MATCH #(
        .CC_CHAR (CC_CHAR)
    )
    read_pattern_match_i
    (
        .DATA_IN(read_data_fifo_i[27:0]),
        .DATA_OUT(read_cc_location_i)
    );

    // Instantiate the FSM for the read side
    CC_2B_1SKP_RFSM #(
        .USE_AUTORECOVER (USE_AUTORECOVER)
    )
    read_fsm_i
    (
        .USER_CLK(USER_RXUSRCLK2),
        .RESET(reset_rxusrclk2_r[0]),
        .BYTE_STATUS(read_cc_location_i),
        .AE_STATUS(almost_empty_r2),
        .AE_INIT(almost_empty_r),
        .SEL_0(read_mux_0_i),
        .SEL_1(read_mux_1_i),
        .REN(rd_en_i),
        .RFSM_IDLE(rfsm_idle_i),
        .INSERTED_CC(inserted_cc_i),
        .MAILBOX_OVERFLOW(rfsm_mailbox_overflow_i)
    );


    //__________________________ FIFO Instantiation __________________________

    // Fifo used to transfer data and control between read/write clock domains
    // Clock correction characters are inserted/deleted to insure FIFO is
    // never full or empty.

    FIFO18_36 #(
        .ALMOST_FULL_OFFSET   (FIFO_ALMOST_FULL_OFFSET),
        .ALMOST_EMPTY_OFFSET  (FIFO_ALMOST_EMPTY_OFFSET),
        .DO_REG               (1),        // Enable output register (0 or 1)
                                          // Must be 1 if EN_SYN = "FALSE"
        .EN_SYN               ("FALSE"),  // "FALSE" - asynchronous
                                          // "TRUE"  - synchronous
        .FIRST_WORD_FALL_THROUGH ("FALSE")
    )
    cc_fifo (
        .ALMOSTEMPTY  (almost_empty_i),
        .ALMOSTFULL   (almost_full_i),
        .DO           (read_data_fifo_i[31:0]),
        .DOP          (read_data_fifo_i[35:32]),
        .EMPTY        (empty_i),
        .FULL         (full_i),
        .RDCOUNT      (),
        .RDERR        (rd_err_i),
        .WRCOUNT      (),
        .WRERR        (wr_err_i),
        .DI           (write_data_fifo_i[31:0]),
        .DIP          (write_data_fifo_i[35:32]),
        .RDCLK        (USER_RXUSRCLK2),
        .RDEN         (rd_en_i),
        .RST          (reset_rxusrclk2_r[0]),
        .WRCLK        (GT_RXUSRCLK2),
        .WREN         (wr_en_i)
    );


    //__________________________ Status Indicators ___________________________

    // Error signal indicator
    // WRERR from the FIFO is synchronous to GT_RXUSRCLK2 - need to double flop
    //  it to the USER_RXUSRCLK2 domain.
    always @(posedge USER_RXUSRCLK2)
    begin
        if (reset_rxusrclk2_r[0])
        begin
            wr_err_r  <= `DLY 1'b0;
            wr_err_r2 <= `DLY 1'b0;
        end
        else
        begin
            wr_err_r  <= `DLY wr_err_rxrecclk_domain_r;
            wr_err_r2 <= `DLY wr_err_r;
        end
    end

    always @(posedge GT_RXUSRCLK2)
        if (reset_rxrecclk_r[0])
            wr_err_rxrecclk_domain_r <= `DLY 1'b0;
        else
            wr_err_rxrecclk_domain_r <= `DLY wr_err_i|wfsm_mailbox_overflow_i;

    // Decode all the signals for the USER_RXBUFSTATUS[2:0]
    // USER_RXBUFSTATUS[2:0] = 101 - Rx elastic underflow
    //    Condition when GT_RXBUFSTATUS[2] or RDERR FIFO is High
    // USER_RXBUFSTATUS[2:0] = 110 - Rx elastic overflow
    //    Condition when GT_RXBUFSTATUS[2] or WRERR FIFO is High
    // GT_RXBUFSTATUS[2] from the GTX is piped through the FIFO as bit 32 of
    //    the data
    assign user_rxbufstatus_c[2] = wr_err_r2 | rd_err_i |
                                 rfsm_mailbox_overflow_i|read_data_fifo_i[32];
    assign user_rxbufstatus_c[1] = wr_err_r2;
    assign user_rxbufstatus_c[0] = rd_err_i | rfsm_mailbox_overflow_i;

    // Register the USER_RXBUFSTATUS[2:0] before presenting it to the user
    always @(posedge USER_RXUSRCLK2)
        if (reset_rxusrclk2_r[0])
            user_rxbufstatus_r[2:0] <= `DLY 3'b000;
        else
            user_rxbufstatus_r[2:0] <= `DLY user_rxbufstatus_c[2:0];

    assign USER_RXBUFSTATUS[2:0] = user_rxbufstatus_r[2:0];

    // Register the inserted_cc_i signal
    always @(posedge USER_RXUSRCLK2)
        if (reset_rxusrclk2_r[0])
            inserted_cc_r <= `DLY 1'b0;
        else
            inserted_cc_r <= `DLY inserted_cc_i;

    // Register the deleted_cc_i signal that is piped through the FIFO as
    // bit 33 of the data
    always @(posedge USER_RXUSRCLK2)
        if (reset_rxusrclk2_r[0])
            deleted_cc_r <= `DLY 1'b0;
        else
            deleted_cc_r <= `DLY read_data_fifo_i[33];

    // Decode all the signals for the USER_RXCLKCORCNT[2:0]
    // USER_RXCLKCORCNT[2:0] = 000 - No clock correction
    // USER_RXCLKCORCNT[2:0] = 001 - 1 CC_CHAR skipped
    // USER_RXCLKCORCNT[2:0] = 111 - 1 CC_CHAR added
    assign user_rxclkcorcnt_c[2:0] = deleted_cc_r ? 3'b001 :
                                        (inserted_cc_r ? 3'b111 : 3'b000);

    // Register the USER_RXCLKCORCNT[2:0] before presenting it to the user
    always @(posedge USER_RXUSRCLK2)
        if (reset_rxusrclk2_r[0])
            user_rxclkcorcnt_r[2:0] <= `DLY 3'b000;
        else
            user_rxclkcorcnt_r[2:0] <= `DLY user_rxclkcorcnt_c[2:0];

    assign USER_RXCLKCORCNT[2:0] = user_rxclkcorcnt_r[2:0];

endmodule

module CC_2B_1SKP_DATA_PATH
(
    input               CLK,
    input     [27:0]    DATA_IN,
    input     [1:0]     SEL_0,
    input     [1:0]     SEL_1,
    input               RST,
    output    [27:0]    DATA_OUT
);

    // Reg declarations
    reg       [13:0]     data_s0_0 = 14'h0000;
    reg       [13:0]     data_s0_1 = 14'h0000;
    reg       [13:0]     data_s1_0 = 14'h0000;
    reg       [13:0]     data_s1_1 = 14'h0000;
    reg       [13:0]     data_s2_0 = 14'h0000;
    reg       [13:0]     data_s2_1 = 14'h0000;

    reg       [13:0]     data_s2_0_d;
    reg       [13:0]     data_s2_1_d;
    
    // synthesis attribute ASYNC_REG of data_s2_0 is "TRUE";
    // synthesis attribute ASYNC_REG of data_s2_1 is "TRUE";
    // synthesis attribute ASYNC_REG of data_s1_0 is "TRUE";
    // Main body of the code
    assign DATA_OUT    = {data_s2_1, data_s2_0};

    always @(SEL_0 or data_s0_0 or data_s0_1 or data_s1_0 or data_s1_1)
    begin
        case (SEL_0)
            2'b00:  data_s2_0_d = data_s1_0;
            2'b01:  data_s2_0_d = data_s0_0;
            2'b10:  data_s2_0_d = data_s0_1;
            2'b11:  data_s2_0_d = data_s1_1;
        endcase
    end

    always @(SEL_1 or data_s0_0 or data_s0_1 or data_s1_0 or data_s1_1)
    begin
        case (SEL_1)
            2'b00:  data_s2_1_d = data_s1_1;
            2'b01:  data_s2_1_d = data_s0_1;
            2'b10:  data_s2_1_d = data_s0_0;
            2'b11:  data_s2_1_d = data_s1_0;
        endcase
    end

    // Storage registers
    always @(posedge CLK)
    begin: data_reg
      data_s0_0 <= `DLY DATA_IN[13:0];
      data_s0_1 <= `DLY DATA_IN[27:14];
      data_s1_0 <= `DLY data_s0_0;
      data_s1_1 <= `DLY data_s0_1;
    end

    // Clear the flops on the last stage of the data path
    always @(posedge CLK)
    begin
        if (RST)
        begin
            data_s2_0 <= `DLY 14'h0000;
            data_s2_1 <= `DLY 14'h0000;
        end
        else
        begin
            data_s2_0 <= `DLY data_s2_0_d;
            data_s2_1 <= `DLY data_s2_1_d;
        end
    end

endmodule

module CC_2B_1SKP_PATTERN_MATCH # (
    //  Define the byte to detect
    parameter CC_CHAR = 8'h1c
)
(
    input       [27:0]  DATA_IN,
    output reg  [1:0]   DATA_OUT
);

    // Wires declaration
    wire    [7:0]     match_char;

    // Main body of the code
    assign match_char = CC_CHAR;

    always @ (DATA_IN, match_char)
    begin
        // Lower portion of the word is the match_char - i.e. xx[CC_CHAR]
        // DATA_IN[8] is RXCHARISK from the data path
        if (DATA_IN[8:0] == {1'b1, match_char})
            DATA_OUT = 2'b01;

        // Upper portion of the word is the match_char - i.e. [CC_CHAR]xx
        // DATA_IN[24] is RXCHARISK from the data path
        else if (DATA_IN[22:14] == {1'b1, match_char})
            DATA_OUT = 2'b10;

        // Lower & upper portions of the word are the match_char
        // i.e. [CC_CHAR][CC_CHAR]
        else if ({DATA_IN[22:14], DATA_IN[8:0]} ==
                  {1'b1, match_char, 1'b1, match_char})
            DATA_OUT = 2'b01;

        // No match
        else
            DATA_OUT = 2'b00;
    end
endmodule

module CC_2B_1SKP_RFSM # (
    parameter USE_AUTORECOVER = 1'b1
)
(
    input               USER_CLK,
    input               RESET,
    input               AE_STATUS,   // Almost Empty flag status *pulse*
    input               AE_INIT,     // Almost Empty flag status *not a pulse*
    input       [1:0]   BYTE_STATUS, // Sequence status
    output  reg [1:0]   SEL_0,
    output  reg [1:0]   SEL_1,
    output  reg         REN,
    output              RFSM_IDLE,
    output              INSERTED_CC,
    output  reg         MAILBOX_OVERFLOW
);

    // FSM states
    parameter INIT            = 0,
              READ_CNT0       = 1,
              READ_CNT0_WAIT  = 2,
              INS_CNT0_0      = 3,
              INS_CNT0_1      = 4,
              READ_CNT1       = 5,
              INS_CNT1_0      = 6,
              INS_CNT1_1      = 7,
              INS_CNT1_2      = 8,
              WAIT_FIFO_CLEAR = 9;

    reg   [9:0]   CurrentState;
    reg   [1:0]   status_RCNT0_r;
    reg   [1:0]   status_RCNT1_r;
    reg   [1:0]   wait_fifo_clear_cnt_r;
    reg   [1:0]   mailbox_r;

    // synthesis attribute ASYNC_REG of CurrentState is "TRUE";
    // synthesis attribute ASYNC_REG of status_RCNT0_r is "TRUE";
    // synthesis attribute ASYNC_REG of status_RCNT1_r is "TRUE";
    // synthesis attribute ASYNC_REG of wait_fifo_clear_cnt_r is "TRUE";
    // synthesis attribute ASYNC_REG of mailbox_r is "TRUE";

    //___________________________ Status registers definition ________________
    // status_RCNT0_r[1:0] - Registered value of the [CC_CHAR} location
    // status_RCNT1_r[1:0] -
    //    2'b00 = normal case with no CC_CHAR
    //    2'b01 = CC_CHAR in lower portion or both lower and upper portion
    //    2'b10 = CC_CHAR in upper portion only


    //___________________________ Read FSM ___________________________________
    always @(posedge USER_CLK)
    begin: SEQ
        if(RESET)
        begin
            CurrentState         <= `DLY 10'b00_0000_0000;
            CurrentState[INIT]   <= `DLY 1'b1;
            status_RCNT0_r       <= `DLY 2'b00;
            status_RCNT1_r       <= `DLY 2'b00;
        end

        else
        begin
            CurrentState <= `DLY 10'b00_0000_0000;

            case (1'b1) /* synthesis parallel_case */
                CurrentState[INIT]        : begin
                    if (AE_INIT == 1'b0)
                        CurrentState[READ_CNT0] <= `DLY 1'b1;
                    else
                        CurrentState[INIT] <= `DLY 1'b1;
                end

                CurrentState[READ_CNT0]   : begin
                    if (mailbox_r != 2'b00)
                        CurrentState[READ_CNT0_WAIT] <= `DLY 1'b1;
                    else
                        CurrentState[READ_CNT0] <= `DLY 1'b1;

                    // Reset the status flag for RCNT1
                    status_RCNT1_r <= `DLY 2'b00;
                end

                CurrentState[READ_CNT0_WAIT]    : begin
                  if(BYTE_STATUS != 2'b00)
                  begin
                      CurrentState[INS_CNT0_0] <= `DLY 1'b1;
                      status_RCNT0_r <= `DLY BYTE_STATUS;
                  end
                  else
                  begin
                      CurrentState[READ_CNT0_WAIT] <= `DLY 1'b1;
                      status_RCNT0_r <= `DLY 2'b00;
                  end
                end

                CurrentState[INS_CNT0_0]    : begin
                    CurrentState[INS_CNT0_1] <= `DLY 1'b1;
                end

                CurrentState[INS_CNT0_1]    : begin
                    CurrentState[READ_CNT1] <= `DLY 1'b1;
                end

                CurrentState[READ_CNT1]     : begin
                    if (BYTE_STATUS != 2'b00)
                    begin
                        CurrentState[INS_CNT1_0] <= `DLY 1'b1;
                        status_RCNT1_r <= `DLY BYTE_STATUS;
                    end
                    else
                    begin
                        CurrentState[READ_CNT1] <= `DLY 1'b1;
                        status_RCNT1_r <= `DLY 2'b00;
                    end
                end

                // Special case
                CurrentState[INS_CNT1_0]    : begin
                    CurrentState[INS_CNT1_1] <= `DLY 1'b1;
                end

                CurrentState[INS_CNT1_1]    : begin
                    CurrentState[INS_CNT1_2] <= `DLY 1'b1;
                end

                CurrentState[INS_CNT1_2]    : begin
                    CurrentState[WAIT_FIFO_CLEAR] <= `DLY 1'b1;

                    //Don't clear this value until this state
                    //CurrentState[INS_CNT1_1]
                    status_RCNT0_r <= `DLY 2'b00;

                end

                // State to give the FIFO enough time to de-assert the Almost
                // Empty Flag after the de-assertion of the REN signal
                CurrentState[WAIT_FIFO_CLEAR]: begin
                    if (wait_fifo_clear_cnt_r == 2'b00)
                        CurrentState[READ_CNT0] <= `DLY 1'b1;
                    else
                        CurrentState[WAIT_FIFO_CLEAR] <= `DLY 1'b1;
                end

                /* synthesis translate_off */
                default                     : begin
                    $display("Error. Default state\n");
                    $stop;
                end
                /* synthesis translate_on */

            endcase
        end
    end


    //__________________ Output of the Read FSM ______________________________
    always @(CurrentState or status_RCNT0_r or status_RCNT1_r)
    begin: OUTPUT_LOGIC

        case(1'b1)
            CurrentState[INIT]          : begin
                SEL_0 = 2'b00; SEL_1 = 2'b00; REN = 1'b0;
            end

            CurrentState[READ_CNT0], CurrentState[READ_CNT0_WAIT],
            CurrentState[WAIT_FIFO_CLEAR]     : begin
                SEL_0 = 2'b01; SEL_1 = 2'b01; REN = 1'b1;
            end

            // Special case
            CurrentState[INS_CNT0_0]    : begin
                REN = 1'b1;
                case(status_RCNT0_r)
                    // 2'b00: SEL_0 = 2'b00; SEL_1 = 2'b00;
                    // It will not get to this state
                    2'b01: begin SEL_0 = 2'b01; SEL_1 = 2'b10;  end
                    2'b10: begin SEL_0 = 2'b01; SEL_1 = 2'b01;  end
                    // 2'b11: SEL_0 = 2'b00; SEL_1 = 2'b00;
                    // It will not get to this state
                    default: begin SEL_0 = 2'b00; SEL_1 = 2'b00;  end
                endcase
            end

            CurrentState[INS_CNT0_1]    : begin
                SEL_0 = 2'b11; SEL_1 = 2'b10; REN = 1'b1;
            end

            CurrentState[READ_CNT1]     : begin
                SEL_0 = 2'b11; SEL_1 = 2'b10; REN = 1'b1;
            end

            CurrentState[INS_CNT1_0]    : begin
                SEL_0 = 2'b11; SEL_1 = 2'b10; REN = 1'b0; end

            // Special case
            CurrentState[INS_CNT1_1]    : begin
                REN = 1'b1;
                case(status_RCNT1_r)
                    // 2'b00: SEL_0 = 2'b00; SEL_1 = 2'b00;
                    // It will not get to this state
                    2'b01: begin SEL_0 = 2'b00; SEL_1 = 2'b00;  end
                    2'b10: begin SEL_0 = 2'b11; SEL_1 = 2'b00;  end
                    // 2'b11: SEL_0 = 2'b00; SEL_1 = 2'b00;
                    // It will not get to this state
                    default: begin SEL_0 = 2'b00; SEL_1 = 2'b00;  end
                endcase
            end

            // Special case
            CurrentState[INS_CNT1_2]    : begin
                REN = 1'b1;
                if ((status_RCNT1_r == 2'b10) && (status_RCNT0_r == 2'b10))
                begin
                    SEL_0 = 2'b00;
                    SEL_1 = 2'b00;
                end
                else
                begin
                    SEL_0 = 2'b01;
                    SEL_1 = 2'b01;
                end

            end

            default                     : begin
                SEL_0 = 2'b00; SEL_1 = 2'b00; REN = 1'b1;
            end

        endcase
    end

    //_____________ Counter for waiting for the FIFO to be clear _____________
    always @(posedge USER_CLK)
        if (RESET)
            wait_fifo_clear_cnt_r <= `DLY 2'b11;
        else if (CurrentState[WAIT_FIFO_CLEAR] == 1'b1)
            wait_fifo_clear_cnt_r <= `DLY wait_fifo_clear_cnt_r - 1'b1;

    //_____________ Generate a CC_CHAR insert indicator signal _______________
    assign INSERTED_CC =  (CurrentState[INS_CNT0_0] == 1'b1) ||
                          (CurrentState[INS_CNT1_0] == 1'b1);

    generate
      if (USE_AUTORECOVER)
        begin : generate_mailbox
          //_____________ Generate Mailbox logic _____________________________
          always @(posedge USER_CLK)
          begin
              if (RESET)
                  mailbox_r <= `DLY 2'b00;
              else
              begin
                  case ( {AE_STATUS, CurrentState[INS_CNT1_2]} )
                      2'b10: begin
                          mailbox_r <= `DLY mailbox_r + 1;
                      end
                      2'b01: begin
                          mailbox_r <= `DLY mailbox_r - 1;
                      end
                  endcase
              end
          end

          always @(posedge USER_CLK)
          begin
              if (RESET)
                  MAILBOX_OVERFLOW <= `DLY 1'b0;
              else if (!MAILBOX_OVERFLOW)
                  MAILBOX_OVERFLOW <= `DLY (mailbox_r == 2'b11) &
                                      (AE_STATUS & ~CurrentState[INS_CNT1_2]);
          end
        end
      else
        begin : generate_no_mailbox
            always @(posedge USER_CLK) MAILBOX_OVERFLOW <= 1'b0;
            always @* mailbox_r = {AE_STATUS,AE_STATUS};
        end

    endgenerate

    assign RFSM_IDLE = CurrentState[READ_CNT0];

endmodule

module CC_2B_1SKP_WFSM #(
   parameter USE_AUTORECOVER = 1'b1
)
(
    input               USER_CLK,
    input               RESET,
    input               AF_STATUS,    // Almost Full Flag status *pulse*
    input       [1:0]   BYTE_STATUS,  // Sequence status
    output  reg [1:0]   SEL_0,
    output  reg [1:0]   SEL_1,
    output  reg         WEN,
    output              WFSM_IDLE,
    output              DELETED_CC,
    output  reg         MAILBOX_OVERFLOW
);

    // FSM states
    parameter INIT            = 0,
              WRITE_CNT0      = 1,
              WRITE_CNT0_WAIT = 2,
              DEL_CNT0_0      = 3,
              DEL_CNT0_1      = 4,
              WRITE_CNT1      = 5,
              DEL_CNT1_0      = 6,
              DEL_CNT1_1      = 7,
              DEL_CNT1_2      = 8,
              WAIT_FIFO_CLEAR = 9;

    reg   [9:0]   CurrentState;
    reg   [1:0]   status_WCNT0_r;
    reg   [1:0]   status_WCNT1_r;
    reg   [1:0]   wait_fifo_clear_cnt_r;
    reg   [1:0]   mailbox_r;

    // synthesis attribute ASYNC_REG of CurrentState is "TRUE";
    // synthesis attribute ASYNC_REG of status_WCNT0_r is "TRUE";
    // synthesis attribute ASYNC_REG of status_WCNT1_r is "TRUE";
    // synthesis attribute ASYNC_REG of wait_fifo_clear_cnt_r is "TRUE";
    // synthesis attribute ASYNC_REG of mailbox_r is "TRUE";
    
    //___________________________ Status registers definition ________________
    // status_WCNT0_r[1:0] - Registered value of the [CC_CHAR} location
    // status_WCNT1_r[1:0] -
    //    2'b00 = normal case with no CC_CHAR
    //    2'b01 = CC_CHAR in lower portion or both lower and upper portion
    //    2'b10 = CC_CHAR in upper portion only


    //__________________________ Write FSM ___________________________________
    always @(posedge USER_CLK)
    begin: SEQ
        if(RESET)
        begin
          CurrentState       <= `DLY 10'b00_0000_0000;
          CurrentState[INIT] <= `DLY 1'b1;
          status_WCNT0_r     <= `DLY 2'b00;
          status_WCNT1_r     <= `DLY 2'b00;
        end

        else
        begin
            CurrentState <= `DLY 10'b00_0000_0000;

            case (1'b1) /* synthesis parallel_case */
                CurrentState[INIT]          : begin
                    CurrentState[WRITE_CNT0] <= `DLY 1'b1;
                end

                CurrentState[WRITE_CNT0]    : begin
                    if (mailbox_r != 2'b00)
                      CurrentState[WRITE_CNT0_WAIT] <= `DLY 1'b1;
                    else
                      CurrentState[WRITE_CNT0] <= `DLY 1'b1;

                    status_WCNT1_r <= `DLY 2'b00; // Reset the status flag
                end

                CurrentState[WRITE_CNT0_WAIT]   : begin
                  if (BYTE_STATUS != 2'b00)
                  begin
                     CurrentState[DEL_CNT0_0] <= `DLY 1'b1;
                     status_WCNT0_r <= `DLY BYTE_STATUS;
                  end
                  else
                  begin
                      CurrentState[WRITE_CNT0_WAIT] <= `DLY 1'b1;
                      status_WCNT0_r <= `DLY 2'b00;
                  end
                end

                CurrentState[DEL_CNT0_0]    : begin
                    CurrentState[DEL_CNT0_1] <= `DLY 1'b1;
                end

                //Special case
                CurrentState[DEL_CNT0_1]    : begin
                    CurrentState[WRITE_CNT1] <= `DLY 1'b1;
                end

                CurrentState[WRITE_CNT1]    : begin
                    if (BYTE_STATUS != 2'b00)
                    begin
                        CurrentState[DEL_CNT1_0] <= `DLY 1'b1;
                        status_WCNT1_r <= `DLY BYTE_STATUS;
                    end
                    else
                    begin
                        CurrentState[WRITE_CNT1] <= `DLY 1'b1;
                        status_WCNT1_r <= `DLY 2'b00;
                    end

                    status_WCNT0_r <= `DLY 2'b00;
                end

                //Special case
                CurrentState[DEL_CNT1_0]    : begin
                    CurrentState[DEL_CNT1_1] <= `DLY 1'b1;
                end

                CurrentState[DEL_CNT1_1]    : begin
                    CurrentState[DEL_CNT1_2] <= `DLY 1'b1;
                end

                CurrentState[DEL_CNT1_2]    : begin
                    CurrentState[WAIT_FIFO_CLEAR] <= `DLY 1'b1;
                end

                // State to give the FIFO enough time to de-assert the Almost
                // Full Flag after the de-assertion of the WREN signal
                CurrentState[WAIT_FIFO_CLEAR]: begin
                    if (wait_fifo_clear_cnt_r == 2'b00)
                        CurrentState[WRITE_CNT0] <= `DLY 1'b1;
                    else
                        CurrentState[WAIT_FIFO_CLEAR] <= `DLY 1'b1;
                end

                /* synthesis translate_off */
                default                     : begin
                    $display("Error. Default state\n");
                    $stop;
                end
                /* synthesis translate_on */

            endcase
        end
    end


    //__________________ Output of the Write FSM _____________________________
    always @(CurrentState or status_WCNT0_r or status_WCNT1_r)
    begin: OUTPUT_LOGIC

        case(1'b1)
            CurrentState[INIT]          : begin
                SEL_0 = 2'b00; SEL_1 = 2'b00; WEN = 1'b0; end

            CurrentState[WRITE_CNT0], CurrentState[WRITE_CNT0_WAIT],
            CurrentState[WAIT_FIFO_CLEAR]    : begin
                SEL_0 = 2'b00; SEL_1 = 2'b00; WEN = 1'b1; end

            CurrentState[DEL_CNT0_0]    : begin
                SEL_0 = 2'b00; SEL_1 = 2'b00; WEN = 1'b1; end

            // Special case
            CurrentState[DEL_CNT0_1]    : begin
                WEN = 1'b1;
                case(status_WCNT0_r)
                    // 2'b00: SEL_0 = 2'b00; SEL_1 = 2'b00;
                    // It will not get to this state
                    2'b01: begin SEL_0 = 2'b11; SEL_1 = 2'b10;  end
                    2'b10: begin SEL_0 = 2'b00; SEL_1 = 2'b10;  end
                    // 2'b11: SEL_0 = 2'b00; SEL_1 = 2'b00;
                    // It will not get to this state
                    default: begin SEL_0 = 2'b00; SEL_1 = 2'b00;  end
                endcase
            end

            CurrentState[WRITE_CNT1]    : begin
                SEL_0 = 2'b11; SEL_1 = 2'b10; WEN = 1'b1; end

            // Special case
            CurrentState[DEL_CNT1_0]    : begin
                WEN = 1'b1;
                case(status_WCNT1_r)
                    // 2'b00: SEL_0 = 2'b00; SEL_1 = 2'b00;
                    // It will not get to this state
                    2'b01: begin SEL_0 = 2'b11; SEL_1 = 2'b01;  end
                    2'b10: begin SEL_0 = 2'b11; SEL_1 = 2'b10;  end
                    // 2'b11: SEL_0 = 2'b00; SEL_1 = 2'b00;
                    // It will not get to this state
                    default: begin SEL_0 = 2'b00; SEL_1 = 2'b00;  end
                endcase
            end

            CurrentState[DEL_CNT1_1]    : begin
                SEL_0 = 2'b01; SEL_1 = 2'b01; WEN = 1'b1;
            end

            CurrentState[DEL_CNT1_2]    : begin
                SEL_0 = 2'b00; SEL_1 = 2'b00; WEN = 1'b0;
            end

            default                     : begin
                SEL_0 = 2'b00; SEL_1 = 2'b00; WEN = 1'b1;
            end

        endcase
    end

    //_____________ Counter for waiting for the FIFO to be clear _____________
    always @(posedge USER_CLK)
        if (RESET)
            wait_fifo_clear_cnt_r <= `DLY 2'b11;
        else if (CurrentState[WAIT_FIFO_CLEAR] == 1'b1)
            wait_fifo_clear_cnt_r <= `DLY wait_fifo_clear_cnt_r - 1'b1;

    //_____________ Generate a CC_CHAR delete indicator signal _______________
    assign DELETED_CC = (CurrentState[DEL_CNT0_0] == 1'b1) ||
                        (CurrentState[DEL_CNT1_0] == 1'b1);

    generate
      if (USE_AUTORECOVER)
        begin : generate_mailbox
          //_____________ Generate Mailbox logic _____________________________
          always @(posedge USER_CLK)
          begin
              if (RESET)
                  mailbox_r <= `DLY 2'b00;
                else
              begin
                  case ( {AF_STATUS, CurrentState[DEL_CNT1_2]} )
                  2'b10: begin
                      mailbox_r <= `DLY mailbox_r + 1;
                  end
                  2'b01: begin
                      mailbox_r <= `DLY mailbox_r - 1;
                  end
                  endcase
              end
          end

          always @(posedge USER_CLK)
          begin
              if (RESET)
                  MAILBOX_OVERFLOW <= `DLY 1'b0;
              else if (!MAILBOX_OVERFLOW)
                  MAILBOX_OVERFLOW <= `DLY (mailbox_r == 2'b11) &
                                      (AF_STATUS & ~CurrentState[DEL_CNT1_2]);
          end
        end
      else
        begin : generate_no_mailbox
          always @(posedge USER_CLK) MAILBOX_OVERFLOW <= 1'b0;
          always @* mailbox_r = {AF_STATUS,AF_STATUS};
        end
    endgenerate

    assign WFSM_IDLE = CurrentState[WRITE_CNT0];

endmodule

