<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver emaclite v3_01_a: xemaclite_l.c File Reference
</title>
<link href="../../../../../../../doc/usenglish/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>xemaclite_l.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file contains the minimal, polled functions to send and receive Ethernet frames.<p>
Refer to <a class="el" href="xemaclite_8h.html">xemaclite.h</a> for more details.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.00a ecm  06/01/02 First release
 1.01a ecm  03/31/04 Additional functionality and the _AlignedRead and
                     _AlignedWrite functions.
 1.11a mta  03/21/07 Updated to new coding style
 2.01a ktn  07/20/09 Updated the XEmacLite_AlignedWrite and
                     XEmacLite_AlignedRead functions to use volatile
                     variables so that they are not optimized.
 3.00a ktn  10/22/09 The macros have been renamed to remove _m from the name.</pre><p>
<pre> </pre> 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemaclite__l_8c.html#1bc0d65a14de4e1538ad98be58c0ae5a">XEmacLite_AlignedWrite</a> (void *SrcPtr, u32 *DestPtr, unsigned ByteCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemaclite__l_8c.html#db507abc2090eb98fb86349ddd7336ad">XEmacLite_AlignedRead</a> (u32 *SrcPtr, void *DestPtr, unsigned ByteCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemaclite__l_8c.html#3ff345b6a7666cf88c2b842dd1fb12d5">XEmacLite_SendFrame</a> (u32 BaseAddress, u8 *FramePtr, unsigned ByteCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemaclite__l_8c.html#10e2e94737cf9a34dd18978e062c6848">XEmacLite_RecvFrame</a> (u32 BaseAddress, u8 *FramePtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="db507abc2090eb98fb86349ddd7336ad"></a><!-- doxytag: member="xemaclite_l.c::XEmacLite_AlignedRead" ref="db507abc2090eb98fb86349ddd7336ad" args="(u32 *SrcPtr, void *DestPtr, unsigned ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacLite_AlignedRead           </td>
          <td>(</td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>SrcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function reads from a 32-bit aligned source address range and aligns the writes to the provided destination pointer alignment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SrcPtr</em>&nbsp;</td><td>is a pointer to incoming data of 32-bit alignment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>is a pointer to outgoing data of any alignment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1bc0d65a14de4e1538ad98be58c0ae5a"></a><!-- doxytag: member="xemaclite_l.c::XEmacLite_AlignedWrite" ref="1bc0d65a14de4e1538ad98be58c0ae5a" args="(void *SrcPtr, u32 *DestPtr, unsigned ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacLite_AlignedWrite           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>SrcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function aligns the incoming data and writes it out to a 32-bit aligned destination address range.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SrcPtr</em>&nbsp;</td><td>is a pointer to incoming data of any alignment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>is a pointer to outgoing data of 32-bit alignment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="10e2e94737cf9a34dd18978e062c6848"></a><!-- doxytag: member="xemaclite_l.c::XEmacLite_RecvFrame" ref="10e2e94737cf9a34dd18978e062c6848" args="(u32 BaseAddress, u8 *FramePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XEmacLite_RecvFrame           </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>FramePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a frame. Wait for a frame to arrive.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FramePtr</em>&nbsp;</td><td>is a pointer to a buffer where the frame will be stored.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
The type/length field of the frame received. When the type/length field contains the type , XEL_MAX_FRAME_SIZE bytes will be copied out of the buffer and it is up to the higher layers to sort out the frame.<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function call is blocking in nature, i.e. it will wait until a frame arrives.<p>
If the ping buffer is the source of the data, the argument should be DeviceAddress + XEL_RXBUFF_OFFSET. If the pong buffer is the source of the data, the argument should be DeviceAddress + XEL_RXBUFF_OFFSET + XEL_BUFFER_OFFSET. The function does not take the different buffers into consideration. 
</div>
</div><p>
<a class="anchor" name="3ff345b6a7666cf88c2b842dd1fb12d5"></a><!-- doxytag: member="xemaclite_l.c::XEmacLite_SendFrame" ref="3ff345b6a7666cf88c2b842dd1fb12d5" args="(u32 BaseAddress, u8 *FramePtr, unsigned ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacLite_SendFrame           </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>FramePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send an Ethernet frame. The size is the total frame size, including header. This function blocks waiting for the frame to be transmitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FramePtr</em>&nbsp;</td><td>is a pointer to frame </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the size, in bytes, of the frame</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function call is blocking in nature, i.e. it will wait until the frame is transmitted. This function can hang and not exit if the hardware is not configured properly.<p>
If the ping buffer is the destination of the data, the argument should be DeviceAddress + XEL_TXBUFF_OFFSET. If the pong buffer is the destination of the data, the argument should be DeviceAddress + XEL_TXBUFF_OFFSET + XEL_BUFFER_OFFSET. The function does not take the different buffers into consideration. 
</div>
</div><p>
<p class="Copyright">
Copyright &copy; 1995-2011 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

