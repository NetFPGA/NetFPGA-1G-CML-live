################################################################################
#
#  NetFPGA-1G-CML http://www.netfpga.org
#
#  File:
#        system.ucf
#
#  Project:
#        loopback_test_nf7
#
#  Author:
#        Jack Meador
#
#  Description:
#        UCF for loopback_test_nf7
#
#  Copyright notice:
#        Copyright (C) 2013 Computer Measurement Laboratory
#
#  Licence:
#        This file is part of the NetFPGA 10G development base package.
#
#        This file is free code: you can redistribute it and/or modify it under
#        the terms of the GNU Lesser General Public License version 2.1 as
#        published by the Free Software Foundation.
#
#        This package is distributed in the hope that it will be useful, but
#        WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#        Lesser General Public License for more details.
#
#        You should have received a copy of the GNU Lesser General Public
#        License along with the NetFPGA source package.  If not, see
#        http://www.gnu.org/licenses/.
#
#

# LOC Constraints

# reset button 1
NET reset        LOC = AC6  | IOSTANDARD=LVCMOS15;
NET clk_in_p     LOC = AA3  | IOSTANDARD=LVDS | VCCAUX_IO=DONTCARE;
NET clk_in_n     LOC = AA2  | IOSTANDARD=LVDS | VCCAUX_IO=DONTCARE;

# PMOD UART
# For PMOD-RS232
# PMOD B 3 - RX
# PMOD B 4 - TX
# NET uart_rx      LOC = H18 | IOSTANDARD=LVCMOS33;
# NET uart_tx      LOC = G19 | IOSTANDARD=LVCMOS33;

# PMOD UART
# For PMODUSBUART 
# PMOD B 3 - RX
# PMOD B 2 - TX
NET uart_rx      LOC = H18 | IOSTANDARD=LVCMOS33;
NET uart_tx      LOC = E15 | IOSTANDARD=LVCMOS33;

# MDIO and PHY Reset
NET mdc          LOC = V13 | IOSTANDARD = LVCMOS18;
NET mdio         LOC = W13 | IOSTANDARD = LVCMOS18;
NET phy_rstn_3  LOC = K21 | IOSTANDARD = LVCMOS33;
NET phy_rstn_4  LOC = L23 | IOSTANDARD = LVCMOS33;
NET phy_rstn_2  LOC = E25 | IOSTANDARD = LVCMOS33;
NET phy_rstn_1  LOC = D18 | IOSTANDARD = LVCMOS33;

# RGMII to PHY 3
NET rgmii_rxd_3[0] LOC = A14 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_3[1] LOC = B14 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_3[2] LOC = E12 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_3[3] LOC = D13 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_3[0] LOC = G12 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_3[1] LOC = F13 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_3[2] LOC = F12 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_3[3] LOC = H11 | IOSTANDARD = LVCMOS18;
NET rgmii_rx_ctl_3 LOC = C13 | IOSTANDARD = LVCMOS18;
NET rgmii_rxc_3    LOC = E11 | IOSTANDARD = LVCMOS18;
NET rgmii_tx_ctl_3 LOC = F10 | IOSTANDARD = LVCMOS18;
NET rgmii_txc_3    LOC = E13 | IOSTANDARD = LVCMOS18;

# RGMII to PHY 4
NET rgmii_rxd_4[0] LOC = B15 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_4[1] LOC = F14 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_4[2] LOC = C14 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_4[3] LOC = H12 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_4[0] LOC = J13 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_4[1] LOC = G14 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_4[2] LOC = H14 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_4[3] LOC = H13 | IOSTANDARD = LVCMOS18;
NET rgmii_rx_ctl_4 LOC = A15 | IOSTANDARD = LVCMOS18;
NET rgmii_rxc_4    LOC = G11 | IOSTANDARD = LVCMOS18;
NET rgmii_tx_ctl_4 LOC = J11 | IOSTANDARD = LVCMOS18;
NET rgmii_txc_4    LOC = D14 | IOSTANDARD = LVCMOS18;

# RGMII to PHY 2
NET rgmii_rxd_2[0] LOC = A13 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_2[1] LOC = C9  | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_2[2] LOC = D11 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_2[3] LOC = C11 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_2[0] LOC = D10 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_2[1] LOC = G10 | IOSTANDARD = LVCMOS18;
NET rgmii_txd_2[2] LOC = D9  | IOSTANDARD = LVCMOS18;
NET rgmii_txd_2[3] LOC = F9  | IOSTANDARD = LVCMOS18;
NET rgmii_rx_ctl_2 LOC = A12 | IOSTANDARD = LVCMOS18;
NET rgmii_rxc_2    LOC = C12 | IOSTANDARD = LVCMOS18;
NET rgmii_tx_ctl_2 LOC = F8  | IOSTANDARD = LVCMOS18;
NET rgmii_txc_2    LOC = J10 | IOSTANDARD = LVCMOS18;

# RGMII to PHY 1
NET rgmii_rxd_1[0] LOC = B11 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_1[1] LOC = A10 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_1[2] LOC = B10 | IOSTANDARD = LVCMOS18;
NET rgmii_rxd_1[3] LOC = A9  | IOSTANDARD = LVCMOS18;
NET rgmii_txd_1[0] LOC = A8  | IOSTANDARD = LVCMOS18;
NET rgmii_txd_1[1] LOC = D8  | IOSTANDARD = LVCMOS18;
NET rgmii_txd_1[2] LOC = G9  | IOSTANDARD = LVCMOS18;
NET rgmii_txd_1[3] LOC = H9  | IOSTANDARD = LVCMOS18;
NET rgmii_rx_ctl_1 LOC = B12 | IOSTANDARD = LVCMOS18;
NET rgmii_rxc_1    LOC = E10 | IOSTANDARD = LVCMOS18;
NET rgmii_tx_ctl_1 LOC = H8  | IOSTANDARD = LVCMOS18;
NET rgmii_txc_1    LOC = B9  | IOSTANDARD = LVCMOS18;

#
# additional constraints
#

NET clk_in TNM_NET = clk_in;
TIMESPEC TS_clk_in = PERIOD clk_in 5000 ps HIGH 50%;

# allows the MMCM to be placed in the other half of the device
NET "clk_in" CLOCK_DEDICATED_ROUTE = BACKBONE;

#
# TEMAC Clocks 
#

NET "rgmii_rxc_*"                  TNM_NET  = "clk_rx";
TIMESPEC "TS_clk_rx"       = PERIOD "clk_rx" 8000 ps HIGH 50 %;

NET "ref_clk"                  TNM_NET  = "ref_clk";
TIMESPEC "TS_ref_clk"       = PERIOD "ref_clk" 5000 ps HIGH 50 %;

NET "gtx_clk"                  TNM_NET  = "gtx_clk";
TIMESPEC "TS_gtx_clk"       = PERIOD "gtx_clk" 8000 ps HIGH 50 %;

NET "gtx_clk90"                TNM_NET  = "gtx_clk90";
TIMESPEC "TS_gtx_clk90"       = PERIOD "gtx_clk90" 8000 ps HIGH 50 %;

#
# High drive for RGMII outputs
#
INST "rgmii_txd*"                                               SLEW = FAST;
INST "rgmii_tx_ctl*"                                            SLEW = FAST;
INST "rgmii_txc*"                                               SLEW = FAST;

#
# RGMII IODELAY 
#
INST "*rgmii_interface*delay_rgmii_rx_ctl"           IDELAY_VALUE = 16;
INST "*rgmii_interface*delay_rgmii_rxd"              IDELAY_VALUE = 16;

# Group IODELAY and IDELAYCTRL components to aid placement
INST "*rgmii_interface*delay_rgmii_rx_ctl"           IODELAY_GROUP = "DLYGRP1";
INST "*rgmii_interface*delay_rgmii_rxd"              IODELAY_GROUP = "DLYGRP1";
INST "*dlyctrl"                                      IODELAY_GROUP = "DLYGRP1";

# Identify RGMII Rx Pads.  
INST "rgmii_rxd_1*"    TNM = IN_RGMII_1; 
INST "rgmii_rx_ctl_1" TNM = IN_RGMII_1;
INST "rgmii_rxd_2*"    TNM = IN_RGMII_2; 
INST "rgmii_rx_ctl_2" TNM = IN_RGMII_2;
INST "rgmii_rxd_3*"    TNM = IN_RGMII_3; 
INST "rgmii_rx_ctl_3" TNM = IN_RGMII_3;
INST "rgmii_rxd_4*"    TNM = IN_RGMII_4; 
INST "rgmii_rx_ctl_4" TNM = IN_RGMII_4;

# The following constraints work in conjunction with IDELAY_VALUE settings to
# check that the RGMII receive bus remains in alignment with the rising and
# falling edges of RGMII_RXC, to within 1.1ns setup time and 1.1ns hold time.
# In addition to adjusting  IDELAY_VALUE settings for your system's timing
# characteristics, you may wish to refine these constraints to match the RGMII
# specification.
 
# due to the early nature of speed files for this family this constraint has
# been relaxed to within 1.5nS setup and hold 
 
TIMEGRP "IN_RGMII_1" OFFSET = IN 1.5 ns VALID 3 ns BEFORE "rgmii_rxc_1" RISING; 
TIMEGRP "IN_RGMII_1" OFFSET = IN 1.5 ns VALID 3 ns BEFORE "rgmii_rxc_1" FALLING;
TIMEGRP "IN_RGMII_2" OFFSET = IN 1.5 ns VALID 3 ns BEFORE "rgmii_rxc_2" RISING; 
TIMEGRP "IN_RGMII_2" OFFSET = IN 1.5 ns VALID 3 ns BEFORE "rgmii_rxc_2" FALLING;
TIMEGRP "IN_RGMII_3" OFFSET = IN 1.5 ns VALID 3 ns BEFORE "rgmii_rxc_3" RISING; 
TIMEGRP "IN_RGMII_3" OFFSET = IN 1.5 ns VALID 3 ns BEFORE "rgmii_rxc_3" FALLING;
TIMEGRP "IN_RGMII_4" OFFSET = IN 1.5 ns VALID 3 ns BEFORE "rgmii_rxc_4" RISING; 
TIMEGRP "IN_RGMII_4" OFFSET = IN 1.5 ns VALID 3 ns BEFORE "rgmii_rxc_4" FALLING;

# Clock Domain Crossing Constraints #
INST    "*/Peripheral_aresetn_0"       TNM = "PReset";
INST    "*gig_eth_mac_block*"   TNM = FFS "UCSD_FFs";

TIMESPEC "TS_PReset_to_UCSD_FFs" = FROM "PReset" TO "UCSD_FFs" TIG;

# Flow Control logic reclocking - control signal is synchronised - use with Xilinx trimac_core only
#INST "*trimac_core*FLOW*PAUSE_REQ_TO_TX*"                        TNM="flow_rx_to_tx";
#INST "*trimac_core*FLOW*PAUSE_VALUE_TO_TX*"                      TNM="flow_rx_to_tx";
#TIMESPEC "TS_flow_rx_to_tx"      = FROM "flow_rx_to_tx" TO gtx_clk 7800 ps DATAPATHONLY;

# Ignore paths to sync flops
INST "*/data_sync"                                                TNM = "resync_reg";
INST "*/reset_sync*"                                              TNM = "resync_reg";
TIMESPEC "ts_resync_flops"       = TO "resync_reg" TIG;

# FIFO clock domain crossing

## TX Client FIFO
INST "*user_side_FIFO/tx_fifo_i/rd_tran_frame_tog"              TNM = "tx_fifo_rd_to_wr";
INST "*user_side_FIFO/tx_fifo_i/rd_addr_txfer*"                 TNM = "tx_fifo_rd_to_wr";
INST "*user_side_FIFO/tx_fifo_i/rd_txfer_tog"                   TNM = "tx_fifo_rd_to_wr";

INST "*user_side_FIFO/tx_fifo_i/wr_frame_in_fifo"               TNM = "tx_fifo_wr_to_rd";

TIMESPEC "TS_tx_fifo_rd_to_wr"   = FROM "tx_fifo_rd_to_wr" TO "gtx_clk" 7800 ps DATAPATHONLY;
TIMESPEC "TS_tx_fifo_wr_to_rd"   = FROM "tx_fifo_wr_to_rd" TO "gtx_clk" 7800 ps DATAPATHONLY;

# Reduce clock period to allow for metastability settling time
# this is a multicycle path due to the resync of the control
INST "*user_side_FIFO/tx_fifo_i/rd_addr_txfer*"                 TNM = "tx_addr_rd";
INST "*user_side_FIFO/tx_fifo_i/wr_rd_addr*"                    TNM = "tx_addr_wr";
TIMESPEC "TS_tx_fifo_addr"       = FROM "tx_addr_rd" TO "tx_addr_wr" 10ns;

## RX Client FIFO
INST "*user_side_FIFO/rx_fifo_i/wr_store_frame_tog"             TNM = "rx_fifo_wr_to_rd";
INST "*user_side_FIFO/rx_fifo_i/rd_addr*"                       TNM = "rx_fifo_rd_to_wr";

TIMESPEC "TS_rx_fifo_wr_to_rd"   = FROM "rx_fifo_wr_to_rd" TO "gtx_clk" 7800 ps DATAPATHONLY;
TIMESPEC "TS_rx_fifo_rd_to_wr"   = FROM "rx_fifo_rd_to_wr" TO "gtx_clk" 7800 ps DATAPATHONLY;

# Ignore stats serialiser clock crossing as handled by toggle sync
#INST "*x_stats_shift*"                                           TNM="sync_ok";
#TIMESPEC "TS_rxstats_sync" = FROM "clk_rx" TO "sync_ok"          TIG;

# Ignore pause deserialiser as only present to prevent logic stripping
#INST "pause_val*"                                                TNM="pause_dsr";
#INST "pause_req*"                                                TNM="pause_dsr";
#TIMESPEC "TS_pause_dsr" = FROM "pause_dsr"                       TIG;
