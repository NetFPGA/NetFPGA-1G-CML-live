------------------------------------------------------------------------------
--
--  NetFPGA-10G http://www.netfpga.org
--
--  File:
--        nf10_axis_memcached_client.vhd
--
--  Library:
--        hw/std/pcores/nf10_axis_memcached_client
--
--  Author:
--        Michaela Blott
--
--  Description:
--                Hardware component that generates and checks packets.
--        Currently the generator generates bit-wise shifted pattern. No valid
--        packet pattern and/or higher layer structure is programmed.
--
--  Copyright notice:
--        Copyright (C) 2010, 2011 Xilinx, Inc.
--
--  Licence:
--        This file is part of the NetFPGA 10G development base package.
--
--        This file is free code: you can redistribute it and/or modify it under
--        the terms of the GNU Lesser General Public License version 2.1 as
--        published by the Free Software Foundation.
--
--        This package is distributed in the hope that it will be useful, but
--        WITHOUT ANY WARRANTY; without even the implied warranty of
--        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--        Lesser General Public License for more details.
--
--        You should have received a copy of the GNU Lesser General Public
--        License along with the NetFPGA source package.  If not, see
--        http://www.gnu.org/licenses/.
--
--

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.NUMERIC_STD.ALL;


entity nf10_axis_memcached_client is
generic (
   C_BASEADDR          : std_logic_vector(31 downto 0) := x"00000000";
   C_HIGHADDR          : std_logic_vector(31 downto 0) := x"00000002";
   C_M_AXIS_DATA_WIDTH : integer := 64; -- max 256bit supported
   C_S_AXIS_DATA_WIDTH : integer := 64; -- max 256bit supported
   C_S_AXIS_TUSER_WIDTH : integer := 128;
   C_M_AXIS_TUSER_WIDTH : integer := 128;
   C_GEN_PKT_SIZE      : integer := 15;--30; -- in words;
   C_CHECK_PKT_SIZE    : integer := 22;--30; -- in words;
   C_IFG_SIZE          : integer := 5;  -- in words irrespective of backpressure
   C_S_AXI_ADDR_WIDTH  : integer := 32;
   C_S_AXI_DATA_WIDTH  : integer := 32;
	DEBUG : integer := 0
);
port (
   ACLK               : in  std_logic;
   ARESETN            : in  std_logic;
   -- axi streaming data interface
   M_AXIS_TDATA       : out std_logic_vector (C_M_AXIS_DATA_WIDTH-1 downto 0);
   M_AXIS_TSTRB       : out std_logic_vector (C_M_AXIS_DATA_WIDTH/8-1 downto 0);
   M_AXIS_TUSER       : out std_logic_vector (C_M_AXIS_TUSER_WIDTH-1 downto 0);
   M_AXIS_TVALID      : out std_logic;
   M_AXIS_TREADY      : in  std_logic;
   M_AXIS_TLAST       : out std_logic;
   S_AXIS_TDATA       : in  std_logic_vector (C_S_AXIS_DATA_WIDTH-1 downto 0);
   S_AXIS_TSTRB       : in  std_logic_vector (C_S_AXIS_DATA_WIDTH/8-1 downto 0);
   S_AXIS_TUSER       : in  std_logic_vector (C_S_AXIS_TUSER_WIDTH-1 downto 0);
   S_AXIS_TVALID      : in  std_logic;
   S_AXIS_TREADY      : out std_logic;
   S_AXIS_TLAST       : in  std_logic;
   -- axi lite control/status interface
   S_AXI_ACLK         : in  std_logic;
   S_AXI_ARESETN      : in  std_logic;
   S_AXI_AWADDR       : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
   S_AXI_AWVALID      : in  std_logic;
   S_AXI_AWREADY      : out std_logic;
   S_AXI_WDATA        : in  std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
   S_AXI_WSTRB        : in  std_logic_vector((C_S_AXI_DATA_WIDTH/8)-1 downto 0);
   S_AXI_WVALID       : in  std_logic;
   S_AXI_WREADY       : out std_logic;
   S_AXI_BRESP        : out std_logic_vector(1 downto 0);
   S_AXI_BVALID       : out std_logic;
   S_AXI_BREADY       : in  std_logic;
   S_AXI_ARADDR       : in  std_logic_vector(C_S_AXI_ADDR_WIDTH-1 downto 0);
   S_AXI_ARVALID      : in  std_logic;
   S_AXI_ARREADY      : out std_logic;
   S_AXI_RDATA        : out std_logic_vector(C_S_AXI_DATA_WIDTH-1 downto 0);
   S_AXI_RRESP        : out std_logic_vector(1 downto 0);
   S_AXI_RVALID       : out std_logic;
   S_AXI_RREADY       : in  std_logic
);
end entity;



architecture structural of nf10_axis_memcached_client is

component axi4_lite_regs_memcached_client
generic (
   ADDR_WIDTH  : integer := 32;
   DATA_WIDTH  : integer := 32
);
port (
   tx_count     : in std_logic_vector(31 downto 0);
   rx_count     : in std_logic_vector(31 downto 0);
   err_count    : in std_logic_vector(31 downto 0);
   count_reset  : out std_logic;
   AXIS_ACLK    : in std_logic;

   -- axi lite control/status interface
   ACLK         : in  std_logic;
   ARESETN      : in  std_logic;
   AWADDR       : in  std_logic_vector(ADDR_WIDTH-1 downto 0);
   AWVALID      : in  std_logic;
   AWREADY      : out std_logic;
   WDATA        : in  std_logic_vector(DATA_WIDTH-1 downto 0);
   WSTRB        : in  std_logic_vector((DATA_WIDTH/8)-1 downto 0);
   WVALID       : in  std_logic;
   WREADY       : out std_logic;
   BRESP        : out std_logic_vector(1 downto 0);
   BVALID       : out std_logic;
   BREADY       : in  std_logic;
   ARADDR       : in  std_logic_vector(ADDR_WIDTH-1 downto 0);
   ARVALID      : in  std_logic;
   ARREADY      : out std_logic;
   RDATA        : out std_logic_vector(DATA_WIDTH-1 downto 0);
   RRESP        : out std_logic_vector(1 downto 0);
   RVALID       : out std_logic;
   RREADY       : in  std_logic
);
end component;

component icon_v5
port (
    CONTROL0 : inout std_logic_vector(35 downto 0);
    CONTROL1 : inout std_logic_vector(35 downto 0));
end component;

component ila256_v5
port (
    CLK     : in std_logic;
    CONTROL : inout std_logic_vector(35 downto 0);
    TRIG0   : in std_logic_vector(255 downto 0));
end component;

component vio_sync64_v5
port (
    CLK      : in std_logic;
    CONTROL  : inout std_logic_vector(35 downto 0);
    SYNC_OUT : out std_logic_vector(63 downto 0));
end component;


   -- ROM should be inferred as BRAM during XST
   constant CHECK_IDLE           : std_logic_vector(1 downto 0) := "00";
   constant CHECK_FINISH         : std_logic_vector(1 downto 0) := "01";
   constant CHECK_COMPARE        : std_logic_vector(1 downto 0) := "11";
   constant CHECK_WAIT_LAST      : std_logic_vector(1 downto 0) := "10";

   constant GEN_PKT              : std_logic_vector(1 downto 0) := "00";
   constant GEN_IFG              : std_logic_vector(1 downto 0) := "01";
   constant GEN_FINISH           : std_logic_vector(1 downto 0) := "11";

   signal gen_word_num       : std_logic_vector(15 downto 0);
   signal gen_state          : std_logic_vector(1  downto 0);
   signal check_state        : std_logic_vector(1  downto 0);
   signal tx_count           : std_logic_vector(31 downto 0);
   signal rx_count           : std_logic_vector(31 downto 0);
   signal err_count          : std_logic_vector(31 downto 0);
   signal count_reset        : std_logic;
   signal ok                 : std_logic;
   signal pkt_tx_buf         : std_logic_vector(C_M_AXIS_DATA_WIDTH-1 downto 0);
   signal pkt_rx_buf         : std_logic_vector(C_S_AXIS_DATA_WIDTH-1 downto 0);
   signal seed               : std_logic_vector(255 downto 0);
	signal i,j : integer;
	signal dyn_ifg : integer;
	
	type pkt_type is array (32 DOWNTO 0) 
      of std_logic_vector(63 DOWNTO 0);
   signal test_pkt_bin : pkt_type;
	signal test_pkt_ascii : pkt_type;
	signal test_pkt_mixed : pkt_type;
   signal check_pkt_bin : pkt_type;	
	signal check_pkt_ascii : pkt_type;
	signal check_pkt_mixed : pkt_type;

	signal ila_data       				: std_logic_vector(255 downto 0);
	signal ila_clk       				: std_logic;
	signal ila_control0   				: std_logic_vector(35 downto 0);
	signal ila_control1   				: std_logic_vector(35 downto 0);
	signal vio_syncout    				: std_logic_Vector(63 downto 0) := x"0000000000000010";
	
	signal gen_pkt_length_int     : integer;
	signal gen_pkt_length         : std_logic_vector(15 downto 0);
	signal gen_pkt_len_tx   		: std_logic_vector(4 downto 0);
	signal check_pkt_len_rx   		: std_logic_vector(7 downto 0);
	signal tstrb                  : std_logic_vector(2 downto 0);
	signal tstrb_byte             : std_logic_vector(7 downto 0);
	
   signal src_port_int           : integer;  
	signal src_port					: std_logic_vector(15 downto 0);
	signal dst_port_int 			   : integer;  
	signal dst_port					: std_logic_vector(15 downto 0);
	signal udp_length_int         : integer;  
	signal udp_length					: std_logic_vector(15 downto 0);
	signal udp_checksum_int       : integer; 
	signal udp_checksum				: std_logic_vector(15 downto 0);
	signal version_int            : integer;  
	signal version						: std_logic_vector(3 downto 0);
	signal ip_header_length_int   : integer;  
	signal ip_header_length			: std_logic_vector(3 downto 0);
	signal type_service_int       : integer;  
	signal type_service				: std_logic_vector(7 downto 0);
	signal total_length_int       : integer;  
	signal total_length				: std_logic_vector(15 downto 0);
	signal identification_int     : integer;  
	signal identification			: std_logic_vector(15 downto 0);
	signal flags_offset_int       : integer;  
	signal flags_offset				: std_logic_vector(15 downto 0);
	signal time_to_live_int       : integer;  
	signal time_to_live				: std_logic_vector(7 downto 0);    
	signal protocol_int           : integer;  
	signal protocol					: std_logic_vector(7 downto 0);   
	signal header_check_sum_int   : integer;  
	signal header_check_sum			: std_logic_vector(15 downto 0);   
	signal ip_src_addr_int        : integer;  
	signal ip_src_addr				: std_logic_vector(31 downto 0);
	signal ip_dest_addr_int       : integer;  
	signal ip_dest_addr				: std_logic_vector(31 downto 0);
	signal dest_mac_int           : integer;   
	signal dest_mac					: std_logic_vector(47 downto 0);
	signal src_mac_int            : integer;   
	signal src_mac						: std_logic_vector(47 downto 0);
	signal l2_type_int            : integer;   
	signal l2_type						: std_logic_vector(15 downto 0);
	signal fcs_int                : integer;   
	signal fcs							: std_logic_vector(31 downto 0);

	signal memcached_protocol     : string(2 downto 0);
	signal magic_number_int 	   : integer;  
	signal magic_number				: std_logic_vector(7 downto 0);
	signal opcode_int 		      : integer;  
	signal opcode						: std_logic_vector(7 downto 0);
	signal key_length_int         : integer;  
	signal key_length					: std_logic_vector(15 downto 0);
	signal extras_length_int      : integer;  
	signal extras_length				: std_logic_vector(7 downto 0);
	signal data_type_int          : integer;  
	signal data_type					: std_logic_vector(7 downto 0);
	signal status_int             : integer;  
	signal status						: std_logic_vector(15 downto 0);
	signal body_length_int        : integer;  
	signal body_length				: std_logic_vector(31 downto 0);
	signal opaque_int             : integer;  
	signal opaque						: std_logic_vector(31 downto 0);
	signal cas_int                : integer;  
	signal cas							: std_logic_vector(63 downto 0); 
   signal key_int                : integer;  
	signal key							: std_logic_vector(31 downto 0);
	signal extras_int             : integer;  
	signal extras						: std_logic_vector(63 downto 0); 
	signal values_int             : integer; 
	signal values						: std_logic_vector(31 downto 0);

	signal memcached_header_length_int  : integer;
	signal l2_header_length_int         : integer;
	signal l3_header_length_int         : integer;
	signal l4_header_length_int         : integer;
	
	signal sr                           : std_logic_vector(191 downto 0);
	signal m_axis_tdata_byte				: std_logic_vector(7 downto 0);

	
	
	
--GET response (174 bytes total, last 132 bytes after the space are the payload):
--b8|cd|a7|ff|ff|00|b8|cd|
--a7|ff|ff|80|08|00|45|00|
--00|a0|00|00|00|00|40|11|
--d2|0d|ac|10|28|14|ac|10|
--28|0b|d6|d8|d6|d9|00|8c|
--1f|75|81|00|00|00|08|00|
--00|00|00|00|00|6c|00|00|
--00|02|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|00|00|
--00|00|00|00|00|00|

	
begin
    
	dyn_ifg <= 5; 
	gen_pkt_length_int <= memcached_header_length_int + l2_header_length_int + 
							l3_header_length_int + l4_header_length_int + key_length_int ;
	gen_pkt_length <= conv_std_logic_vector(gen_pkt_length_int,16);
	gen_pkt_len_tx <= gen_pkt_length(7 downto 3);
	tstrb <= gen_pkt_length(2 downto 0);
	
	
	--L2 Ethernet Header/Footer
	dest_mac <= x"000000F0F0F0";    -- 48 bit 
	dest_mac_int <= conv_integer(dest_mac);
	src_mac <= x"909090909090";     --48 bit
	src_mac_int <= conv_integer(src_mac);
	l2_type <= x"009C";             --16 bit
	l2_type_int <= conv_integer(l2_type);
	fcs <= x"00000000";             --32 bit
	fcs_int <= conv_integer(fcs);
	
	l2_header_length_int <= dest_mac_int + src_mac_int + l2_type_int + fcs_int;
	
	
	--L3 IP Header
	version <= x"4";          --4 bit
	version_int <= conv_integer(version);
	ip_header_length <= x"4";   --4 bit
	ip_header_length_int <= conv_integer(ip_header_length);
	type_service <= x"00";      --8 bit
	type_service_int <= conv_integer(type_service);
	total_length <= x"0000";    --16 bit
	total_length_int <= conv_integer(total_length);
	identification <= x"0000";   --16 bit
	identification_int <= conv_integer(identification);
	flags_offset <= x"0000";     --16 bit
	flags_offset_int <= conv_integer(flags_offset);
	time_to_live <= x"01";        --8 bit
	time_to_live_int <= conv_integer(time_to_live);
	protocol <= x"04";           --8 bit
	protocol_int <= conv_integer(protocol);
	header_check_sum <= x"0000";     --16 bit
	header_check_sum_int <= conv_integer(header_check_sum);
	ip_src_addr <= x"C0A00101";   --32 bit src: 192.168.1.1
	ip_src_addr_int <= conv_integer(ip_src_addr);
	ip_dest_addr <= x"C0A00102";  --32 bit dst: 192.168.1.2
	ip_dest_addr_int <= conv_integer(ip_dest_addr);
	
	l3_header_length_int <= version_int + ip_header_length_int + type_service_int + 
							  total_length_int + identification_int + flags_offset_int + 
							  time_to_live_int + protocol_int + header_check_sum_int + ip_src_addr_int + 
							  ip_dest_addr_int;
		
		
							  
	--L4 UDP Header
	src_port <= x"C000";   --16 bit Private UDP port: 49152
	src_port_int <= conv_integer(src_port);
	dst_port <= x"C001";   --16 bit Private UDP port: 49153
	dst_port_int <= conv_integer(dst_port);
	udp_length <= x"005A"; --16 bit 90 Byte total packet length (UDP Header + data)
   udp_length_int <= conv_integer(udp_length);	
	udp_checksum <= x"0000"; --16 bit
	udp_checksum_int <= conv_integer(udp_checksum);
	
	l4_header_length_int <= src_port_int + dst_port_int + udp_length_int + udp_checksum_int;
	
	--Memcached Header
	memcached_protocol <= "BIN";
	magic_number <= x"80"; --8 bit
	magic_number_int <= conv_integer(magic_number);
	opcode <= x"00";       --8 bit
	opcode_int <= conv_integer(opcode);
	key_length <= x"0014";  --16 bit
	key_length_int <= conv_integer(key_length);
	extras_length <= x"00";  --8 bit
	extras_length_int <= conv_integer(extras_length);
	data_type <= x"00";     --8 bit
	data_type_int <= conv_integer(data_type);
	status <= x"0000";      --16 bit
	status_int <= conv_integer(status);
	body_length <= x"00000014"; --32 bit
	body_length_int <= conv_integer(body_length);
	opaque <= x"00000000";      --32 bit
	opaque_int <= conv_integer(opaque);
	cas <= x"0000000000000000";  --64 bit
	cas_int <= conv_integer(cas);
	
	memcached_header_length_int <= magic_number_int + opcode_int + key_length_int + 
											 extras_length_int + data_type_int + status_int + 
											 body_length_int + opaque_int + cas_int;
	
	--Memcached Data
	extras <= x"0000000000000000"; --64 bit
	extras_int <= conv_integer(extras);
	key <= x"00000000";           --32 bit
	key_int <= conv_integer(key);
	values <= x"00000000";        --32 bit
	values_int <= conv_integer(values);
	
	
	test_pkt_bin(0)   <= dest_mac & src_mac(47 downto 32);
	test_pkt_bin(1)   <= src_mac(31 downto 0) & l2_type & fcs(31 downto 16);
	test_pkt_bin(2)   <= fcs(15 downto 0) & version & ip_header_length & type_service & total_length & identification;
	test_pkt_bin(3)   <= flags_offset & time_to_live & protocol & header_check_sum & ip_src_addr(31 downto 16);
	test_pkt_bin(4)   <= ip_src_addr(15 downto 0) & ip_dest_addr & src_port;
	test_pkt_bin(5)   <= dst_port & udp_length & udp_checksum & magic_number & opcode;
	test_pkt_bin(6)   <= key_length & extras_length & data_type & status & body_length(31 downto 16);
	test_pkt_bin(7)   <= body_length(15 downto 0) & opaque & cas(63 downto 48);
	test_pkt_bin(8)   <= cas(47 downto 0) & key(31 downto 16);   
	test_pkt_bin(9)   <= key(15 downto 0) & x"000000000000";   
	test_pkt_bin(10)  <= x"0000000000000000";
	test_pkt_bin(11)  <= x"0000000000000000";  
	test_pkt_bin(12)  <= x"0000000000000000";
	test_pkt_bin(13)  <= x"0000000000000000"; 
	test_pkt_bin(14)  <= x"0000000000000000";	
   test_pkt_bin(15)  <= x"0000000000000000";

	
	
	check_pkt_bin(0) <= x"cdb8d0270cbae290";
	check_pkt_bin(1) <= x"00450008010100a7";
	check_pkt_bin(2) <= x"114000000000a000";
	check_pkt_bin(3) <= x"0101010101014976";
	check_pkt_bin(4) <= x"8c00d9d6d8d60201";
	check_pkt_bin(5) <= x"000800000081b0c3";
	check_pkt_bin(6) <= x"00006c0000000000";
	check_pkt_bin(7) <= x"0000000000000200";
	check_pkt_bin(8) <= x"0000000000000000";
	check_pkt_bin(9) <= x"0000000000000000";
	check_pkt_bin(10) <= x"0000000000000000";
	check_pkt_bin(11) <= x"0000000000000000";
	check_pkt_bin(12) <= x"0000000000000000";
	check_pkt_bin(13) <= x"0000000000000000";
	check_pkt_bin(14) <= x"0000000000000000";
	check_pkt_bin(15) <= x"0000000000000000";
	check_pkt_bin(16) <= x"0000000000000000";
	check_pkt_bin(17) <= x"0000000000000000";
	check_pkt_bin(18) <= x"0000000000000000";
	check_pkt_bin(19) <= x"0000000000000000";
	check_pkt_bin(20) <= x"0000000000000000";
	check_pkt_bin(21) <= x"0000000000000000";
	
	
	--test_pkt_ascii(0)   <= dest_mac & src_mac(47 downto 32);
	--test_pkt_ascii(1)   <= src_mac(31 downto 0) & l2_type & fcs(31 downto 16);
	--test_pkt_ascii(2)   <= fcs(15 downto 0) & version & ip_header_length & type_service & total_length & identification;
	--test_pkt_ascii(3)   <= flags_offset & time_to_live & protocol & header_check_sum & ip_src_addr(31 downto 16);
	--test_pkt_ascii(4)   <= ip_dest_addr & src_port & dst_port;
	--test_pkt_ascii(5)   <= udp_length & udp_checksum & magic_number & opcode & key_length;
	--test_pkt_ascii(6)   <= extras_length & data_type & status & body_length;
	--test_pkt_ascii(7)   <= opaque & cas(63 downto 32);
	--test_pkt_ascii(8)   <= cas(31 downto 0) & key;   
	--test_pkt_ascii(9)   <= x"0000000000000000";   
	--test_pkt_ascii(10)  <= x"0000000000000000";
	--test_pkt_ascii(11)  <= x"0000000000000000";  
	--test_pkt_ascii(12)  <= x"0000000000000000";
	--test_pkt_ascii(13)  <= x"0000000000000000"; 
	--test_pkt_ascii(14)  <= x"0000000000000000";	
   --test_pkt_ascii(15)  <= x"0000000000000000";

	
	
	--check_pkt_ascii(0) <= x"cdb8d0270cbae290";
	--check_pkt_ascii(1) <= x"00450008010100a7";
	--check_pkt_ascii(2) <= x"114000000000a000";
	--check_pkt_ascii(3) <= x"0101010101014976";
	--check_pkt_ascii(4) <= x"8c00d9d6d8d60201";
	--check_pkt_ascii(5) <= x"000800000081b0c3";
	--check_pkt_ascii(6) <= x"00006c0000000000";
	--check_pkt_ascii(7) <= x"0000000000000200";
	--check_pkt_ascii(8) <= x"0000000000000000";
	--check_pkt_ascii(9) <= x"0000000000000000";
	--check_pkt_ascii(10) <= x"0000000000000000";
	--check_pkt_ascii(11) <= x"0000000000000000";
	--check_pkt_ascii(12) <= x"0000000000000000";
	--check_pkt_ascii(13) <= x"0000000000000000";
	--check_pkt_ascii(14) <= x"0000000000000000";
	--check_pkt_ascii(15) <= x"0000000000000000";
	--check_pkt_ascii(16) <= x"0000000000000000";
	--check_pkt_ascii(17) <= x"0000000000000000";
	--check_pkt_ascii(18) <= x"0000000000000000";
	--check_pkt_ascii(19) <= x"0000000000000000";
	--check_pkt_ascii(20) <= x"0000000000000000";
	--check_pkt_ascii(21) <= x"0000000000000000";
	
	
	--test_pkt_mixed(0)   <= dest_mac & src_mac(47 downto 32);
	--test_pkt_mixed(1)   <= src_mac(31 downto 0) & l2_type & fcs(31 downto 16);
	--test_pkt_mixed(2)   <= fcs(15 downto 0) & version & ip_header_length & type_service & total_length & identification;
	--test_pkt_mixed(3)   <= flags_offset & time_to_live & protocol & header_check_sum & ip_src_addr(31 downto 16);
	--test_pkt_mixed(4)   <= ip_dest_addr & src_port & dst_port;
	--test_pkt_mixed(5)   <= udp_length & udp_checksum & magic_number & opcode & key_length;
	--test_pkt_mixed(6)   <= extras_length & data_type & status & body_length;
	--test_pkt_mixed(7)   <= opaque & cas(63 downto 32);
	--test_pkt_mixed(8)   <= cas(31 downto 0) & key;   
	--test_pkt_mixed(9)   <= x"0000000000000000";   
	--test_pkt_mixed(10)  <= x"0000000000000000";
	--test_pkt_mixed(11)  <= x"0000000000000000";  
	--test_pkt_mixed(12)  <= x"0000000000000000";
	--test_pkt_mixed(13)  <= x"0000000000000000"; 
	--test_pkt_mixed(14)  <= x"0000000000000000";	
   --test_pkt_mixed(15)  <= x"0000000000000000";

	
	
	--check_pkt_mixed(0) <= x"cdb8d0270cbae290";
	--check_pkt_mixed(1) <= x"00450008010100a7";
	--check_pkt_mixed(2) <= x"114000000000a000";
	--check_pkt_mixed(3) <= x"0101010101014976";
	--check_pkt_mixed(4) <= x"8c00d9d6d8d60201";
	--check_pkt_mixed(5) <= x"000800000081b0c3";
	--check_pkt_mixed(6) <= x"00006c0000000000";
	--check_pkt_mixed(7) <= x"0000000000000200";
	--check_pkt_mixed(8) <= x"0000000000000000";
	--check_pkt_mixed(9) <= x"0000000000000000";
	--check_pkt_mixed(10) <= x"0000000000000000";
	--check_pkt_mixed(11) <= x"0000000000000000";
	--check_pkt_mixed(12) <= x"0000000000000000";
	--check_pkt_mixed(13) <= x"0000000000000000";
	--check_pkt_mixed(14) <= x"0000000000000000";
	--check_pkt_mixed(15) <= x"0000000000000000";
	--check_pkt_mixed(16) <= x"0000000000000000";
	--check_pkt_mixed(17) <= x"0000000000000000";
	--check_pkt_mixed(18) <= x"0000000000000000";
	--check_pkt_mixed(19) <= x"0000000000000000";
	--check_pkt_mixed(20) <= x"0000000000000000";
	--check_pkt_mixed(21) <= x"0000000000000000";
	
	
	

--test_pkt(0) <= check_pkt(0);
--test_pkt(1) <= check_pkt(1);
--test_pkt(2) <= check_pkt(2);
--test_pkt(3) <= check_pkt(3);
--test_pkt(4) <= check_pkt(4);
--test_pkt(5) <= check_pkt(5);
--test_pkt(6) <= check_pkt(6);
--test_pkt(7) <= check_pkt(7);
--test_pkt(8) <= check_pkt(8);
--test_pkt(9) <= check_pkt(9);
--test_pkt(10) <= check_pkt(10);
--test_pkt(11) <= check_pkt(11);
--test_pkt(12) <= check_pkt(12);
--test_pkt(13) <= check_pkt(13);
--test_pkt(14) <= check_pkt(14);
--test_pkt(15) <= check_pkt(15);
--test_pkt(16) <= check_pkt(16);
--test_pkt(17) <= check_pkt(17);
--test_pkt(18) <= check_pkt(18);
--test_pkt(19) <= check_pkt(19);
--test_pkt(20) <= check_pkt(20);
----test_pkt(21) <= check_pkt(21);
--test_pkt(21) <= x"0000000000001234";
--test_pkt(8) <= x"0000000000001234";



   regs : axi4_lite_regs_memcached_client
     generic map
        (
        ADDR_WIDTH       => C_S_AXI_ADDR_WIDTH,
        DATA_WIDTH       => C_S_AXI_DATA_WIDTH
        )

     port map
        (
        tx_count  => tx_count,
        rx_count  => rx_count,
        err_count => err_count,
        count_reset => count_reset,
        AXIS_ACLK => ACLK,

        ACLK => S_AXI_ACLK,
        ARESETN => S_AXI_ARESETN,
        AWADDR => S_AXI_AWADDR,
        AWVALID => S_AXI_AWVALID,
        AWREADY => S_AXI_AWREADY,
        WDATA => S_AXI_WDATA,
        WSTRB => S_AXI_WSTRB,
        WVALID => S_AXI_WVALID,
        WREADY => S_AXI_WREADY,
        BRESP => S_AXI_BRESP,
        BVALID => S_AXI_BVALID,
        BREADY => S_AXI_BREADY,
        ARADDR => S_AXI_ARADDR,
        ARVALID => S_AXI_ARVALID,
        ARREADY => S_AXI_ARREADY,
        RDATA => S_AXI_RDATA,
        RRESP => S_AXI_RRESP,
        RVALID => S_AXI_RVALID,
        RREADY => S_AXI_RREADY
        );

ila_data(66) <= '1' when (gen_word_num = gen_pkt_len_tx - 1) else '0';
M_AXIS_TLAST <= '1' when (gen_word_num = gen_pkt_len_tx - 1) else '0';
M_AXIS_TUSER <= (others => '0'); -- Dummy TUSER

ila_data(65) <= M_AXIS_TREADY;

lut_strb: process(tstrb)
begin

	case tstrb is

		when "000" => tstrb_byte <= "11111111";
		when "001" => tstrb_byte <= "00000001";
		when "010" => tstrb_byte <= "00000011";
		when "011" => tstrb_byte <= "00000111";
		when "100" => tstrb_byte <= "00001111";
		when "101" => tstrb_byte <= "00011111";
		when "110" => tstrb_byte <= "00111111";
		when "111" => tstrb_byte <= "01111111";
		when others => tstrb_byte <= "00000000";
	end case;

end process;

m_axis_data: process(m_axis_tdata)
begin

	case m_axis_tdata is

		when "000" => m_axis_tdata_byte <= "11111111";
		when "001" => m_axis_tdata_byte <= "00000001";
		when "010" => m_axis_tdata_byte <= "00000011";
		when "011" => m_axis_tdata_byte <= "00000111";
		when "100" => m_axis_tdata_byte <= "00001111";
		when "101" => m_axis_tdata_byte <= "00011111";
		when "110" => m_axis_tdata_byte <= "00111111";
		when "111" => m_axis_tdata_byte <= "01111111";
		when others => m_axis_tdata_byte <= "00000000";
	end case;

end process;




gen_p: process(ACLK, ARESETN)
begin
   if (ARESETN='0') then
      M_AXIS_TSTRB <= (others => '0');
      M_AXIS_TVALID <= '0';
		ila_data(64) <= '0';
      gen_word_num <= (others => '0');
      tx_count <= (others => '0');
      gen_state <= GEN_IFG; -- initiate to between frames
   elsif (ACLK = '1' and ACLK'event) then   
      if gen_state = GEN_PKT then
		 M_AXIS_TSTRB <= (others => '1');
         M_AXIS_TVALID <= '1';
			ila_data(64) <= '1';
         if (M_AXIS_TREADY='1') then
            gen_word_num <= gen_word_num + 1;
            if (gen_word_num = gen_pkt_len_tx - 1) then
               M_AXIS_TSTRB <= (others => '0');
         		M_AXIS_TVALID <= '0';
					ila_data(64) <= '0';
         		tx_count <= tx_count + 1;
         		gen_state <= GEN_IFG;
            else
					if (memcached_protocol='BIN') then
					i <= i + 1;
						if (gen_word_num=0) then
							M_AXIS_TDATA <= x"0000" & tx_count(7 downto 0) & x"00" & cas(63 downto 32);					
						elsif (gen_word_num=7) then
							
							
							M_AXIS_TDATA <= 
										 
		
                else
						--M_AXIS_TDATA <=  test_pkt_bin(i);
						--ila_data(63 downto 0) <= test_pkt_bin(i);
					 --end if;
					 if (gen_word_num = gen_pkt_len_tx - 2) then	
						M_AXIS_TSTRB <= tstrb_byte;	
					 end if;
            end if;
         end if;
      elsif gen_state = GEN_IFG then
         M_AXIS_TSTRB <= (others => '0');
         M_AXIS_TVALID <= '0';
			ila_data(64) <= '0';
         if (M_AXIS_TREADY='1') then
             gen_word_num <= gen_word_num + 1;
             if gen_word_num = gen_pkt_len_tx+dyn_ifg-1 then
                 if(count_reset = '1') then
          			gen_state <= GEN_IFG; -- Hold state at GEN_IFG gently...
          			--tx_count <= (others => '0');
          		 else
          		    gen_state <= GEN_FINISH;
      			 end if;
             end if;
         end if;
      elsif gen_state = GEN_FINISH then
		   i <= 1;
         M_AXIS_TSTRB <= (others => '1');
         M_AXIS_TVALID <= '1';
			ila_data(64) <= '1';
			ila_data(63 downto 0) <= test_pkt_bin(0);
			M_AXIS_TDATA <= test_pkt_bin(0);
         --M_AXIS_TDATA <= seed(C_M_AXIS_DATA_WIDTH -1 downto 0);
         --pkt_tx_buf <= seed(C_M_AXIS_DATA_WIDTH -1 downto 0);
         gen_word_num <= (others => '0');
         gen_state <= GEN_PKT;
      end if;
   end if;
end process;

S_AXIS_TREADY <= '1';


check_p: process(ACLK, ARESETN)
begin
   if (ARESETN='0') then
        check_state <= (others => '0');
        rx_count <= (others => '0');
        err_count <= (others => '0');
        ok <= '1';
		  j <= 0;
   elsif (ACLK = '1' and ACLK'event) then
		ila_data(191 downto 128) <= S_AXIS_TDATA;
	   ila_data(192) <= S_AXIS_TVALID;
		ila_data(193) <= '1';
		ila_data(194) <= S_AXIS_TLAST;
      ila_data(202 downto 195) <= S_AXIS_TSTRB;
      if check_state = CHECK_IDLE then
         -- waiting for a pkt
         if S_AXIS_TVALID = '1' then
            ok <= '1';
				j <= 1;
            check_state <= CHECK_COMPARE;
         end if;
      elsif check_state = CHECK_COMPARE then
		 -- checking the packet
         -- check packet size and last
         if (S_AXIS_TVALID = '1') then
				 j <= j + 1;
             if (S_AXIS_TDATA = test_pkt_bin(j)) then
					  ok <= ok;
				 else
					if (j=7 or j = C_CHECK_PKT_SIZE -1) then
						ok <= ok;
					else
                 ok <= '0';
					end if;
             end if;
		       if (j = C_CHECK_PKT_SIZE -1) then
		          if (S_AXIS_TLAST='1') then
		              check_state <= CHECK_FINISH; -- finish up
		          else
		              ok <= '0';
		              check_state <= CHECK_WAIT_LAST; -- Wait for last
		          end if;
             end if;
		 end if;
      elsif check_state = CHECK_FINISH then
         -- finish up
         if (ok='1') then
			rx_count <= rx_count + 1;
		 else
			err_count <= err_count + 1;
		 end if;
		 check_state <= CHECK_IDLE;
		 ok <='1';
      elsif check_state = CHECK_WAIT_LAST then
         -- Wait for last
	     if (S_AXIS_TLAST='1' and S_AXIS_TVALID = '1') then
		    check_state <= CHECK_FINISH;
		  end if;
      end if;

--      if(count_reset = '1') then -- Don't touch check state machine..
--          rx_count <= (others => '0');
--          err_count <= (others => '0');
--      end if;
   end if;
end process;


F: if (DEBUG = 1) generate 
begin  
i1_icon : icon_v5
port map(
    CONTROL0  => ila_control0,
    CONTROL1  => ila_control1
);

i1_ila : ila256_v5
port map(
    CLK     => ACLK,
    CONTROL => ila_control0,
    TRIG0   => ila_data
);

i1_vio : vio_sync64_v5
port map(
    CLK      => ACLK,
    CONTROL  => ila_control1,
    SYNC_OUT => vio_syncout
);
end generate F;


end structural;

