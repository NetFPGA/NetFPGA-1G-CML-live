
##################################################################
# a function that writes the header of regs file
##################################################################
def write_regs_header(regsFile):
      regsFile.write('\
/********************************************************************************\n\
 *  NetFPGA-10G http://www.netfpga.org\n\
 *\n\
 *  File:\n\
 *        cpu_regs.v\n\
 *\n\
 *  Module:\n\
 *        cpu_regs\n\
 *\n\
 *  Author:\n\
 *        Noa Zilberman\n\
 *\n\
 *  Description:\n\
 *        This file is automatically generated with the registers towards the CPU/Software\n\
 *\n\
 *  Copyright notice:\n\
 *        Copyright (C) 2013 University of Cambridge\n\
 *\n\
 *  Licence:\n\
 *        This file is part of the NetFPGA 10G development base package.\n\
 *\n\
 *        This file is free code: you can redistribute it and/or modify it under\n\
 *        the terms of the GNU Lesser General Public License version 2.1 as\n\
 *        published by the Free Software Foundation.\n\
 *\n\
 *        This package is distributed in the hope that it will be useful, but\n\
 *        WITHOUT ANY WARRANTY; without even the implied warranty of\n\
 *        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\
 *        Lesser General Public License for more details.\n\
 *\n\
 *        You should have received a copy of the GNU Lesser General Public\n\
 *        License along with the NetFPGA source package.  If not, see\n\
 *        http://www.gnu.org/licenses/.\n\
 *\n\
 */\n\n')
#end of write_regs_headerdefault

##################################################################
# a function that writes the header of regs defines file
##################################################################

def write_defs_header(defsFile):
      defsFile.write('\
/********************************************************************************\n\
 *  NetFPGA-10G http://www.netfpga.org\n\
 *\n\
 *  File:\n\
 *        cpu_regs_defines.v\n\
 *\n\
 *  Module:\n\
 *        cpu_regs_defines\n\
 *\n\
 *  Author:\n\
 *        Noa Zilberman\n\
 *\n\
 *  Description:\n\
 *        This file is automatically generated with the registers defintions towards the CPU/Software\n\
 *\n\
 *  Copyright notice:\n\
 *        Copyright (C) 2013 University of Cambridge\n\
 *\n\
 *  Licence:\n\
 *        This file is part of the NetFPGA 10G development base package.\n\
 *\n\
 *        This file is free code: you can redistribute it and/or modify it under\n\
 *        the terms of the GNU Lesser General Public License version 2.1 as\n\
 *        published by the Free Software Foundation.\n\
 *\n\
 *        This package is distributed in the hope that it will be useful, but\n\
 *        WITHOUT ANY WARRANTY; without even the implied warranty of\n\
 *        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\
 *        Lesser General Public License for more details.\n\
 *\n\
 *        You should have received a copy of the GNU Lesser General Public\n\
 *        License along with the NetFPGA source package.  If not, see\n\
 *        http://www.gnu.org/licenses/.\n\
 *\n\
 */\n\n')

#end of write_defs_header


##################################################################
# a function that writes the header of regs tcl file
##################################################################

def write_tcl_header(tclFile):
      tclFile.write('\
 ################################################################################\n\
 #  NetFPGA-10G http://www.netfpga.org\n\
 #\n\
 #  File:\n\
 #        module_name.tcl\n\
 #\n\
 #  Author:\n\
 #        Noa Zilberman\n\
 #\n\
 #  Description:\n\
 #        This file is automatically generated with the registers names for the software\n\
 #\n\
 #  Copyright notice:\n\
 #        Copyright (C) 2013 University of Cambridge\n\
 #\n\
 #  Licence:\n\
 #        This file is part of the NetFPGA 10G development base package.\n\
 #\n\
 #        This file is free code: you can redistribute it and/or modify it under\n\
 #        the terms of the GNU Lesser General Public License version 2.1 as\n\
 #        published by the Free Software Foundation.\n\
 #\n\
 #        This package is distributed in the hope that it will be useful, but\n\
 #        WITHOUT ANY WARRANTY; without even the implied warranty of\n\
 #        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\
 #        Lesser General Public License for more details.\n\
 #\n\
 #        You should have received a copy of the GNU Lesser General Public\n\
 #        License along with the NetFPGA source package.  If not, see\n\
 #        http://www.gnu.org/licenses/.\n\
 #\n\
 #\n\n')

#end of write_tcl_header

##################################################################
#A funtion that writes the ports of the regs moduledefault
##################################################################
def write_regs_ports(regsFile,regsDict):

   regsFile.write('`include "cpu_regs_defines.v"\n\
\
 module cpu_regs \n\
 #(\n\
    parameter C_S_AXI_DATA_WIDTH    = 32,          \n\
    parameter C_S_AXI_ADDR_WIDTH    = 32,          \n\
    parameter C_USE_WSTRB           = 0,	   \n\
    parameter C_DPHASE_TIMEOUT      = 0,           \n\
    parameter C_BASEADDR            = 32\'hFFFFFFFF,\n\
    parameter C_HIGHADDR            = 32\'h00000000,\n\
    parameter C_S_AXI_ACLK_FREQ_HZ  = 100           \n\
 )\n\
 (\n\
   // General ports\n\
    input      clk,\n\
    input      resetn,\n\
   // Global Registers\n\
   input      cpu_resetn_soft,\n\
   output reg resetn_soft,\n\
   output reg resetn_sync,\n\
\n\
   // Register ports\n')

   for entry in regsDict:
     if entry['type']=="RO" :
       regsFile.write('    input      [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg,\n')
     if entry['type']=="ROC" :
       regsFile.write('    input      [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg,\n')
       regsFile.write('    output reg                          '+entry['name']+'_reg_clear,\n')
     if entry['type']=="RWS" :
       regsFile.write('    output reg [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg,\n')
     if entry['type']=="WO" :
       regsFile.write('    output reg [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg,\n')
     if entry['type']=="WOE" :
       regsFile.write('    output reg [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg,\n')
     if entry['type']=="RWA" :
       regsFile.write('    input      [`REG_'+(entry['name']).upper()+'_BITS]    ip2cpu_'+entry['name']+'_reg,\n')
       regsFile.write('    output reg [`REG_'+(entry['name']).upper()+'_BITS]    cpu2ip_'+entry['name']+'_reg,\n')
     if entry['type']=="RWCR" :
       regsFile.write('    input      [`REG_'+(entry['name']).upper()+'_BITS]    ip2cpu_'+entry['name']+'_reg,\n')
       regsFile.write('    output reg [`REG_'+(entry['name']).upper()+'_BITS]    cpu2ip_'+entry['name']+'_reg,\n')
       regsFile.write('    output reg                          cpu2ip_'+entry['name']+'_reg_clear,\n')
     if entry['type']=="RWCW" :
       regsFile.write('    input      [`REG_'+(entry['name']).upper()+'_BITS]    ip2cpu_'+entry['name']+'_reg,\n')
       regsFile.write('    output reg [`REG_'+(entry['name']).upper()+'_BITS]    cpu2ip_'+entry['name']+'_reg,\n')
       regsFile.write('    output reg                          cpu2ip_'+entry['name']+'_reg_clear,\n')

   regsFile.write('\n\
  // AXI Lite ports\n\
    input                                     S_AXI_ACLK,\n\
    input                                     S_AXI_ARESETN,\n\
    input      [C_S_AXI_ADDR_WIDTH-1 : 0]     S_AXI_AWADDR,\n\
    input                                     S_AXI_AWVALID,\n\
    input      [C_S_AXI_DATA_WIDTH-1 : 0]     S_AXI_WDATA,\n\
    input      [C_S_AXI_DATA_WIDTH/8-1 : 0]   S_AXI_WSTRB,\n\
    input                                     S_AXI_WVALID,\n\
    input                                     S_AXI_BREADY,\n\
    input      [C_S_AXI_ADDR_WIDTH-1 : 0]     S_AXI_ARADDR,\n\
    input                                     S_AXI_ARVALID,\n\
    input                                     S_AXI_RREADY,\n\
    output                                    S_AXI_ARREADY,\n\
    output     [C_S_AXI_DATA_WIDTH-1 : 0]     S_AXI_RDATA,\n\
    output     [1 : 0]                        S_AXI_RRESP,\n\
    output                                    S_AXI_RVALID,\n\
    output                                    S_AXI_WREADY,\n\
    output     [1 :0]                         S_AXI_BRESP,\n\
    output                                    S_AXI_BVALID,\n\
    output                                    S_AXI_AWREADY\n\
\n\
);\n')
#end of write_regs_ports

##################################################################
#A funtion that writes the wires and regs of the registers module
##################################################################
def write_regs_wires(regsFile,regsDict):

   regsFile.write('\n\
    reg                                             resetn_sync_d;\n\
    wire                                            Bus2IP_Clk;\n\
    wire                                            Bus2IP_Resetn;\n\
    wire     [C_S_AXI_ADDR_WIDTH-1 : 0]             Bus2IP_Addr;\n\
    wire     [0:0]                                  Bus2IP_CS;\n\
    wire                                            Bus2IP_RNW;\n\
    wire     [C_S_AXI_DATA_WIDTH-1 : 0]             Bus2IP_Data;\n\
    wire     [C_S_AXI_DATA_WIDTH/8-1 : 0]           Bus2IP_BE;\n\
    wire     [C_S_AXI_DATA_WIDTH-1 : 0]             IP2Bus_Data;\n\
    wire                                            IP2Bus_RdAck;\n\
    wire                                            IP2Bus_WrAck;\n\
  \n\
    wire [C_S_AXI_ADDR_WIDTH-1 : 0]                 bus2ip_addr_sync;\n\
    wire [0:0]                                      bus2ip_cs_sync;\n\
    wire                                            bus2ip_rnw_sync;\n\
    wire [C_S_AXI_DATA_WIDTH-1 : 0]                 bus2ip_data_sync;\n\
    wire [C_S_AXI_DATA_WIDTH/8-1 : 0]               bus2ip_be_sync;\n\
    reg  [C_S_AXI_DATA_WIDTH-1 : 0]                 ip2bus_data_sync;\n\
    reg                                             ip2bus_rdack_sync;\n\
    reg                                             ip2bus_wrack_sync;\n\
    wire                                            ip2bus_error_sync;\n\
    wire                                            bus2ip_sync_valid;\n');
   
   for entry in regsDict:
      if entry['type']=="RWCW" :
         regsFile.write('    reg                                             cpu2ip_'+entry['name']+'_reg_clear_d;\n')

#end of write_regs_wires

##################################################################
#instantiate sub-modules
##################################################################
def instantiate_submodules(regsFile):

  regsFile.write('\n\
  //ipif_xbar block\n\
  axi_lite_ipif_1bar\n#(\n\
    .C_S_AXI_DATA_WIDTH (C_S_AXI_DATA_WIDTH),\n\
    .C_S_AXI_ADDR_WIDTH (C_S_AXI_ADDR_WIDTH),\n\
    .C_USE_WSTRB        (C_USE_WSTRB),\n\
    .C_DPHASE_TIMEOUT   (C_DPHASE_TIMEOUT),\n\
    .C_BAR0_BASEADDR    (C_BASEADDR),\n\
    .C_BAR0_HIGHADDR    (C_HIGHADDR)\n\
  ) axi_lite_ipif_inst\n\
  (\n\
    .S_AXI_ACLK          ( S_AXI_ACLK     ),\n\
    .S_AXI_ARESETN       ( S_AXI_ARESETN  ),\n\
    .S_AXI_AWADDR        ( S_AXI_AWADDR   ),\n\
    .S_AXI_AWVALID       ( S_AXI_AWVALID  ),\n\
    .S_AXI_WDATA         ( S_AXI_WDATA    ),\n\
    .S_AXI_WSTRB         ( S_AXI_WSTRB    ),\n\
    .S_AXI_WVALID        ( S_AXI_WVALID   ),\n\
    .S_AXI_BREADY        ( S_AXI_BREADY   ),\n\
    .S_AXI_ARADDR        ( S_AXI_ARADDR   ),\n\
    .S_AXI_ARVALID       ( S_AXI_ARVALID  ),\n\
    .S_AXI_RREADY        ( S_AXI_RREADY   ),\n\
    .S_AXI_ARREADY       ( S_AXI_ARREADY  ),\n\
    .S_AXI_RDATA         ( S_AXI_RDATA    ),\n\
    .S_AXI_RRESP         ( S_AXI_RRESP    ),\n\
    .S_AXI_RVALID        ( S_AXI_RVALID   ),\n\
    .S_AXI_WREADY        ( S_AXI_WREADY   ),\n\
    .S_AXI_BRESP         ( S_AXI_BRESP    ),\n\
    .S_AXI_BVALID        ( S_AXI_BVALID   ),\n\
    .S_AXI_AWREADY       ( S_AXI_AWREADY  ),\n\
	\n\
	// Controls to the IP/IPIF modules\n\
    .Bus2IP_Clk          ( Bus2IP_Clk     ),\n\
    .Bus2IP_Resetn       ( Bus2IP_Resetn  ),\n\
    .Bus2IP_Addr         ( Bus2IP_Addr    ),\n\
    .Bus2IP_RNW          ( Bus2IP_RNW     ),\n\
    .Bus2IP_BE           ( Bus2IP_BE      ),\n\
    .Bus2IP_CS           ( Bus2IP_CS      ),\n\
    .Bus2IP_Data         ( Bus2IP_Data    ),\n\
    .IP2Bus_Data         ( IP2Bus_Data    ),\n\
    .IP2Bus_WrAck        ( IP2Bus_WrAck   ), \n\
    .IP2Bus_RdAck        ( IP2Bus_RdAck   ), \n\
    .IP2Bus_Error        ( IP2Bus_Error   )\n\
  );\n\
\n\
  //synchronization module\n\
cpu_sync \n\
#(\n\
    .C_S_AXI_DATA_WIDTH    (C_S_AXI_DATA_WIDTH),\n\
    .C_S_AXI_ADDR_WIDTH    (C_S_AXI_ADDR_WIDTH)\n\
) cpu_sync_inst\n\
(\n\
    //ip clock domain\n\
    .clk                    (clk),\n\
    .resetn                 (resetn_sync),\n\
    .bus2ip_addr_sync       (bus2ip_addr_sync),\n\
    .bus2ip_cs_sync         (bus2ip_cs_sync),\n\
    .bus2ip_rnw_sync        (bus2ip_rnw_sync),\n\
    .bus2ip_data_sync       (bus2ip_data_sync),\n\
    .bus2ip_be_sync         (bus2ip_be_sync),\n\
    .bus2ip_sync_valid      (bus2ip_sync_valid),\n\
    .ip2bus_data_sync       (ip2bus_data_sync),\n\
    .ip2bus_rdack_sync      (ip2bus_rdack_sync),\n\
    .ip2bus_wrack_sync      (ip2bus_wrack_sync),\n\
    .ip2bus_error_sync      (ip2bus_error_sync),\n\
    \n\
    //axi clock domain\n\
    .Bus2IP_Clk             (Bus2IP_Clk),\n\
    .Bus2IP_Resetn          (Bus2IP_Resetn),\n\
\n\
    .Bus2IP_Addr            (Bus2IP_Addr),\n\
    .Bus2IP_CS              (Bus2IP_CS),\n\
    .Bus2IP_RNW             (Bus2IP_RNW),\n\
    .Bus2IP_Data            (Bus2IP_Data),\n\
    .Bus2IP_BE              (Bus2IP_BE),\n\
    .IP2Bus_Data            (IP2Bus_Data),\n\
    .IP2Bus_RdAck           (IP2Bus_RdAck),\n\
    .IP2Bus_WrAck           (IP2Bus_WrAck),\n\
    .IP2Bus_Error           (IP2Bus_Error)\n\
\n\
);\n');

#end of instantiate_submodules

##################################################################
#sync reset signal for better timing
##################################################################
def sync_reset(regsFile):

   regsFile.write('\n\
  //Sample reset (not mandatory, but good practice)\n\
   always @(posedge clk)\n\
   if (!resetn) begin\n\
      resetn_sync_d  <= #1 1\'b0;\n\
      resetn_sync    <= #1 1\'b0;\n\
   end\n\
   else begin\n\
      resetn_sync_d  <= #1 resetn;\n\
      resetn_sync    <= #1 resetn_sync_d;\n\
   end\n');


#end of sync_reset

##################################################################
#ack ipif read and write commands
##################################################################
def ack_ipif(regsFile):

   regsFile.write('\n\
   //Handle ACK signals (note that the timing is correct)\n\
   reg new_event;\n\
   always @(posedge clk)\n\
   if (!resetn_sync) begin\n\
      ip2bus_wrack_sync <= #1 1\'b0;\n\
      ip2bus_rdack_sync <= #1 1\'b0;\n\
      new_event <= #1 1\'b1;\n\
   end\n\
   else begin\n\
     ip2bus_wrack_sync <= #1 bus2ip_cs_sync && !bus2ip_rnw_sync && new_event  ;\n\
     ip2bus_rdack_sync <= #1 bus2ip_cs_sync && bus2ip_rnw_sync && new_event  ;\n\
	 // new_event <= #1 !bus2ip_cs_sync ? 1\'b1: 1\'b0;\n\
     new_event <= #1 ~bus2ip_sync_valid ? new_event : !bus2ip_cs_sync ? 1\'b1: 1\'b0;\n\
   end\n\
\n\
   assign ip2bus_error_sync = 1\'b0; //unless we need it... but no error event is currently handled\n');

#end of ack_ipif


##################################################################
# a function that writes the logic behind the registers access
##################################################################
def write_logic(regsFile,regsDict):
  # boolean first_item;
   #for now, only global reset is supported, to demonstrate usage
   regsFile.write('\n\
   //global registers, sampling\n\
   always @(posedge clk) resetn_soft <= #1 cpu_resetn_soft;\n');
   
   #return read data 
   regsFile.write('\n//Return value to CPU on read\n\
   always @(posedge clk) \n\
   if (!resetn_sync) begin\n\
        ip2bus_data_sync[31:0] <= #1 32\'hDEADBEEF;\n\
   end\n\
   else begin\n\
      if (C_S_AXI_DATA_WIDTH>32)\n\
         ip2bus_data_sync[C_S_AXI_DATA_WIDTH:32] <= #1 0;\n\
      if ( bus2ip_cs_sync && bus2ip_rnw_sync ) begin\n\
         case (bus2ip_addr_sync)\n');

   for entry in regsDict:
      if  entry['type']=="RO" or entry['type']=="ROC" or entry['type']=="RWS":
         regsFile.write('         //'+entry['name'].capitalize()+' Register\n\
         `REG_'+entry['name'].upper()+'_ADDR : begin\n\
             ip2bus_data_sync [`REG_'+entry['name'].upper()+'_BITS] <= #1 '+entry['name']+'_reg;\n\
             if (`REG_'+entry['name'].upper()+'_WIDTH<32)\n\
                ip2bus_data_sync [31:`REG_'+entry['name'].upper()+'_WIDTH] <= #1 \'b0;\n\
        end\n');
        
      if entry['type']=="RWCW" or entry['type']=="RWA" or entry['type']=="RWCR":
         regsFile.write('         //'+entry['name'].capitalize()+' Register\n\
         `REG_'+entry['name'].upper()+'_ADDR : begin\n\
             ip2bus_data_sync [`REG_'+entry['name'].upper()+'_BITS] <= #1 ip2cpu_'+entry['name']+'_reg;\n\
             if (`REG_'+entry['name'].upper()+'_WIDTH<32)\n\
                ip2bus_data_sync [31:`REG_'+entry['name'].upper()+'_WIDTH] <= #1 \'b0;\n\
        end\n');
        

   regsFile.write('         //Default return value\n\
         default: begin \n\
             ip2bus_data_sync [31:0] <= #1 32\'hDEADBEEF;\n\
         end\n\
      endcase\n\
    end\n\
  end//end of assigning data to IP2Bus_Data bus\n');

   #Handle read only registers
   first_item=True;

   for entry in regsDict:
      if entry['type']=="ROC" :
         if first_item:
            first_item=False;
            regsFile.write('     //Read only registers, not cleared\n\
   //Nothing to do here....\n\
   \n\
   //Read only registers, cleared on read (e.g. counters)\n\
   always @(posedge clk)\n\
   if (!resetn_sync) begin \n');

         regsFile.write('\
      '+entry['name']+'_reg_clear <= #1 1\'b0;\n');
 
   if not(first_item):
            regsFile.write('   end\n\
   else begin\n');


   for entry in regsDict:
      if entry['type']=="ROC" :
         regsFile.write('      '+entry['name']+'_reg_clear <= #1(bus2ip_cs_sync && bus2ip_rnw_sync && (bus2ip_addr_sync==`REG_'+entry['name'].upper()+'_ADDR)) ? 1\'b1 : 1\'b0;\n');
   
   if not(first_item):
      regsFile.write('   end\n\n');

 #Handle write only registers

   first_item=True; 

   for entry in regsDict:
      if entry['type']=="WO" :
         if first_item:
            regsFile.write('     //Write only register, not cleared\n\
            //static  \n\
             always @(posedge clk)\n\
             if (!resetn_sync) begin\n');
            first_item=False;
      
         regsFile.write('           '+entry['name']+'_reg <= #1 `REG_'+entry['name']+'_DEFAULT;\n');


   if not(first_item):
      regsFile.write('       end\n\
       else begin\n\
           if (bus2ip_cs_sync && !(bus2ip_rnw_sync)) //write event\n\
           case (bus2ip_addr_sync)        \n');

   for entry in regsDict:
      if entry['type']=="WO" :
         regsFile.write('           //'+entry['name'].capitalize()+' Register\n\
             `REG_'+entry['name'].upper()+'_ADDR : begin\n\
                '+entry['name']+'_reg <= #1 bus2ip_data_sync[`REG_'+entry['name'].upper()+'_BITS];\n\
             end\n');
 
   if not(first_item):
      regsFile.write('      endcase\n\
    end\n\n');

 #Handle write only event registers
 
   first_item = True;

   for entry in regsDict:
         if entry['type']=="WOE" :
            if first_item:
               first_item= False;
               regsFile.write('     //Write only register, clear on write (i.e. event)\n\
       always @(posedge clk)\n\
       if (!resetn_sync) begin\n');

            regsFile.write('           '+entry['name']+'_reg <= #1 `REG_'+entry['name'].upper()+'_DEFAULT;\n');

   if not(first_item):
      regsFile.write('       end\n\
       else begin\n');
 
   for entry in regsDict:
      if entry['type']=="WOE" :
         regsFile.write('          '+entry['name']+'_reg <= #1 bus2ip_cs_sync && !(bus2ip_rnw_sync) && (bus2ip_addr_sync==`REG_'+entry['name'].upper()+'_ADDR) ? \n\
            bus2ip_data_sync[`REG_'+entry['name'].upper()+'_BITS] : `REG_'+entry['name'].upper()+'_DEFAULT;\n');

   if not(first_item):
         regsFile.write('       end\n');

#Handle Read/write registers, not cleared

   first_item=True;
   
   
   for entry in regsDict:
      if first_item and (entry['type']=="RWS" or entry['type']=="RWA"):
          first_item = False;
          regsFile.write('     //R/W register, not cleared\n\
       always @(posedge clk)\n\
       if (!resetn_sync) begin\n');
   
      if entry['type']=="RWS" :
         regsFile.write('           '+entry['name']+'_reg <= #1 `REG_'+entry['name'].upper()+'_DEFAULT;\n');
      if entry['type']=="RWA" :
         regsFile.write('           cpu2ip_'+entry['name']+'_reg <= #1 `REG_'+entry['name'].upper()+'_DEFAULT;\n');

   if not(first_item):
      regsFile.write('       end\n\
       else begin\n\
           if (bus2ip_cs_sync && !(bus2ip_rnw_sync)) //write event\n\
           case (bus2ip_addr_sync)\n');

   for entry in regsDict:
      if entry['type']=="RWS" :
         regsFile.write('         //'+entry['name'].capitalize()+' Register\n\
           `REG_'+entry['name'].upper()+'_ADDR : begin\n\
            '+entry['name']+'_reg <= #1 bus2ip_data_sync[`REG_'+entry['name'].upper()+'_BITS]; //static register;\n\
            end\n');
      if entry['type']=="RWA" :
         regsFile.write('         //'+entry['name'].capitalize()+' Register\n\
           `REG_'+entry['name'].upper()+'_ADDR : begin\n\
            cpu2ip_'+entry['name']+'_reg <= #1 bus2ip_data_sync[`REG_'+entry['name'].upper()+'_BITS]; //dynamic register;\n\
            end\n');

   if not (first_item):
      regsFile.write('        default: begin\n\
          end\n\
        endcase\n\
      end\n\n');

#Handle Read/write registers, clear on read
   
   first_item=True;
   
   for entry in regsDict:
      if entry['type']=="RWCR" :
         if first_item:
           first_item = False;
           regsFile.write('  //R/W register, clear on read\n\
       always @(posedge clk)\n\
       if (!resetn_sync) begin\n');

         regsFile.write('        cpu2ip_'+entry['name']+'_reg <= #1 `REG_'+entry['name'].upper()+'_DEFAULT;\n');

   if not(first_item):
      regsFile.write('       end\n\
       else begin\n\
           if (bus2ip_cs_sync && !(bus2ip_rnw_sync))\n');
   
   for entry in regsDict:
      if entry['type']=="RWCR" :
          regsFile.write('             if (bus2ip_addr_sync==`REG_'+entry['name'].upper()+'_ADDR)\n\
                cpu2ip_'+entry['name']+'_reg <= #1 bus2ip_data_sync[`REG_'+entry['name'].upper()+'_BITS];\n');

   if not(first_item):
      regsFile.write('       end\n\n\
       //clear assertions\n\
       always @(posedge clk)\n\
          if (!resetn_sync) begin\n');

   for entry in regsDict:
      if entry['type']=="RWCR" :
         regsFile.write('	      cpu2ip_'+entry['name']+'_reg_clear <=  #1 1\'b0;\n');

   if not(first_item):
      regsFile.write('          end\n\
          else begin\n');

   for entry in regsDict:
      if entry['type']=="RWCR" :
         regsFile.write('             cpu2ip_'+entry['name']+'_reg_clear <=  #1 bus2ip_cs_sync && bus2ip_rnw_sync && (bus2ip_addr_sync==`REG_'+entry['name'].upper()+'_ADDR) ? 1\'b1 : 1\'b0;\n');

   if not(first_item):
      regsFile.write('          end\n');

#Handle Read/write registers, clear on write

   first_item= True;
   for entry in regsDict:
      if entry['type']=="RWCW" :
         first_item = False;
         regsFile.write('  //R/W register, clear on write, dynamic\n\
   // i.e. on write - write, next clock - write default value\n\
       always @(posedge clk)\n\
       if (!resetn_sync) begin\n');

         regsFile.write('           cpu2ip_'+entry['name']+'_reg <= #1 `REG_'+entry['name'].upper()+'_DEFAULT;\n\
           cpu2ip_'+entry['name']+'_reg_clear_d <= #1 1\'b0;\n\
           cpu2ip_'+entry['name']+'_reg_clear   <= #1 1\'b0;\n');

   if not(first_item):
      regsFile.write('       end\n\
       else begin\n');

   for entry in regsDict:
      if entry['type']=="RWCW" :
         regsFile.write('           cpu2ip_'+entry['name']+'_reg_clear   <= #1 cpu2ip_'+entry['name']+'_reg_clear_d;\n\
	   cpu2ip_'+entry['name']+'_reg_clear_d <= #1 (bus2ip_cs_sync && !(bus2ip_rnw_sync)) && (bus2ip_addr_sync==`REG_'+entry['name'].upper()+'_ADDR) ? 1\'b1 :  1\'b0;\n');

   if not(first_item):
      regsFile.write('           if (bus2ip_cs_sync && !(bus2ip_rnw_sync)) begin\n');

   for entry in regsDict:
      if entry['type']=="RWCW" :
         regsFile.write('              if (bus2ip_addr_sync==`REG_'+entry['name'].upper()+'_ADDR) begin\n\
                 cpu2ip_'+entry['name']+'_reg <= #1 bus2ip_data_sync[`REG_'+entry['name'].upper()+'_BITS];\n\
              end\n');

				 
   if not(first_item):
      regsFile.write('	   end\n\
       end\n');
# end of write_logic

##################################################################
#write all the defines to the defs module
##################################################################
def write_defines(defsFile,regsDict):

   for entry in regsDict:
      defsFile.write('           `define  REG_'+entry['name'].upper()+'_BITS        '+entry['bits']+'\n\
           `define  REG_'+entry['name'].upper()+'_WIDTH        '+entry['width']+'\n\
           `define  REG_'+entry['name'].upper()+'_DEFAULT        '+entry['default']+'\n\
           `define  REG_'+entry['name'].upper()+'_ADDR        '+entry['addr']+'\n');

#end of write_defines

##################################################################
#write all the register offsets to the mpd template (to be included)
##################################################################
def write_mpd(mpdFile,regsDict):

   mpdFile.write('##########This text should be copied to the MPD file #############\n\
   #Registers offset definitions\n\n');
   
   for entry in regsDict:
      mpdFile.write('PARAMETER '+entry['name'].upper()+' = 0x'+entry['addr'].lstrip('32\'h')+', DT = INTEGER, BUS = S_AXI, ASSIGNMENT = CONSTANT, TYPE = NON_HDL\n');

#end of write_mpd

##################################################################
#write all the register offsets to the tcl file
##################################################################
def write_tcl(tclFile,regsDict):

   tclFile.write('proc generate {drv_handle} {\n\
       #---------------------------\n\
       # #defines in xparameters.h\n\
       #---------------------------\n\
       xdefine_include_file $drv_handle "xparameters.h" ');
   
   for entry in regsDict:
     tclFile.write('"'+entry['name'].upper()+'" ');
   
   tclFile.write('}\n');
#end of write_tcl


##################################################################
#write top module's template (i.e. include this in your module)
##################################################################
def write_module_template(moduleFile,regsDict):

#first write static inclusions....
  moduleFile.write('`uselib lib=proc_common_v3_00_a\n\
`include "cpu_regs_defines.v"\n\
\n\
//parameters to be added to the top module parameters\n\
#(\n\
    // AXI Registers Data Width\n\
    parameter C_S_AXI_DATA_WIDTH    = 32,\n\
    parameter C_S_AXI_ADDR_WIDTH    = 32,\n\
    parameter C_USE_WSTRB           = 0,\n\
    parameter C_DPHASE_TIMEOUT      = 0,\n\
    parameter C_BASEADDR            = 32\'hFFFFFFFF,\n\
    parameter C_HIGHADDR            = 32\'h00000000,\n\
    parameter C_S_AXI_ACLK_FREQ_HZ  = 100\n\
)\n\
//ports to be added to the top module ports\n\
(\n\
// Signals for AXI_IP and IF_REG (Added for debug purposes)\n\
    // Slave AXI Ports\n\
    input                                     S_AXI_ACLK,\n\
    input                                     S_AXI_ARESETN,\n\
    input      [C_S_AXI_ADDR_WIDTH-1 : 0]     S_AXI_AWADDR,\n\
    input                                     S_AXI_AWVALID,\n\
    input      [C_S_AXI_DATA_WIDTH-1 : 0]     S_AXI_WDATA,\n\
    input      [C_S_AXI_DATA_WIDTH/8-1 : 0]   S_AXI_WSTRB,\n\
    input                                     S_AXI_WVALID,\n\
    input                                     S_AXI_BREADY,\n\
    input      [C_S_AXI_ADDR_WIDTH-1 : 0]     S_AXI_ARADDR,\n\
    input                                     S_AXI_ARVALID,\n\
    input                                     S_AXI_RREADY,\n\
    output                                    S_AXI_ARREADY,\n\
    output     [C_S_AXI_DATA_WIDTH-1 : 0]     S_AXI_RDATA,\n\
    output     [1 : 0]                        S_AXI_RRESP,\n\
    output                                    S_AXI_RVALID,\n\
    output                                    S_AXI_WREADY,\n\
    output     [1 :0]                         S_AXI_BRESP,\n\
    output                                    S_AXI_BVALID,\n\
    output                                    S_AXI_AWREADY\n\
)\n\n');

#then add design specific wires/regs:

  for entry in regsDict:
     if entry['type']=="RO" :
       moduleFile.write('    reg      [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg;\n')
     if entry['type']=="ROC" :
       moduleFile.write('    reg      [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg;\n')
       moduleFile.write('    wire                             '+entry['name']+'_reg_clear;\n')
     if entry['type']=="RWS" :
       moduleFile.write('    wire     [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg;\n')
     if entry['type']=="WO" :
       moduleFile.write('    wire     [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg;\n')
     if entry['type']=="WOE" :
       moduleFile.write('    wire     [`REG_'+(entry['name']).upper()+'_BITS]    '+entry['name']+'_reg;\n')
     if entry['type']=="RWA" :
       moduleFile.write('    reg      [`REG_'+(entry['name']).upper()+'_BITS]    ip2cpu_'+entry['name']+'_reg;\n')
       moduleFile.write('    wire     [`REG_'+(entry['name']).upper()+'_BITS]    cpu2ip_'+entry['name']+'_reg;\n')
     if entry['type']=="RWCR" :
       moduleFile.write('    reg      [`REG_'+(entry['name']).upper()+'_BITS]    ip2cpu_'+entry['name']+'_reg;\n')
       moduleFile.write('    wire     [`REG_'+(entry['name']).upper()+'_BITS]    cpu2ip_'+entry['name']+'_reg;\n')
       moduleFile.write('    wire                             cpu2ip_'+entry['name']+'_reg_clear;\n')
     if entry['type']=="RWCW" :
       moduleFile.write('    reg      [`REG_'+(entry['name']).upper()+'_BITS]    ip2cpu_'+entry['name']+'_reg;\n')
       moduleFile.write('    wire     [`REG_'+(entry['name']).upper()+'_BITS]    cpu2ip_'+entry['name']+'_reg;\n')
       moduleFile.write('    wire                             cpu2ip_'+entry['name']+'_reg_clear;\n')
       moduleFile.write('    wire                             cpu2ip_'+entry['name']+'_reg_clear_d;\n')

#instantiate registers module
  moduleFile.write('\n//Registers section\n\
 cpu_regs \n\
 #(\n\
     .C_S_AXI_DATA_WIDTH    (C_S_AXI_DATA_WIDTH),\n\
     .C_S_AXI_ADDR_WIDTH    (C_S_AXI_ADDR_WIDTH),\n\
     .C_USE_WSTRB           (C_USE_WSTRB),\n\
     .C_DPHASE_TIMEOUT      (C_DPHASE_TIMEOUT),\n\
     .C_BASEADDR            (C_BASEADDR),\n\
     .C_HIGHADDR            (C_HIGHADDR),\n\
     .C_S_AXI_ACLK_FREQ_HZ  (C_S_AXI_ACLK_FREQ_HZ)\n\
 ) cpu_regs_inst\n\
 (   \n\
   // General ports\n\
    .clk                    (axi_aclk),\n\
    .resetn                 (axi_resetn),\n\
   // AXI Lite ports\n\
    .S_AXI_ACLK             (S_AXI_ACLK),\n\
    .S_AXI_ARESETN          (S_AXI_ARESETN),\n\
    .S_AXI_AWADDR           (S_AXI_AWADDR),\n\
    .S_AXI_AWVALID          (S_AXI_AWVALID),\n\
    .S_AXI_WDATA            (S_AXI_WDATA),\n\
    .S_AXI_WSTRB            (S_AXI_WSTRB),\n\
    .S_AXI_WVALID           (S_AXI_WVALID),\n\
    .S_AXI_BREADY           (S_AXI_BREADY),\n\
    .S_AXI_ARADDR           (S_AXI_ARADDR),\n\
    .S_AXI_ARVALID          (S_AXI_ARVALID),\n\
    .S_AXI_RREADY           (S_AXI_RREADY),\n\
    .S_AXI_ARREADY          (S_AXI_ARREADY),\n\
    .S_AXI_RDATA            (S_AXI_RDATA),\n\
    .S_AXI_RRESP            (S_AXI_RRESP),\n\
    .S_AXI_RVALID           (S_AXI_RVALID),\n\
    .S_AXI_WREADY           (S_AXI_WREADY),\n\
    .S_AXI_BRESP            (S_AXI_BRESP),\n\
    .S_AXI_BVALID           (S_AXI_BVALID),\n\
    .S_AXI_AWREADY          (S_AXI_AWREADY),\n\
   \n\
   // Register ports\n');

  for entry in regsDict:
     if entry['type']=="RO"  :
       moduleFile.write('   .'+entry['name']+'_reg          ('+entry['name']+'_reg),\n')
     if entry['type']=="ROC" :
       moduleFile.write('   .'+entry['name']+'_reg          ('+entry['name']+'_reg),\n')
       moduleFile.write('   .'+entry['name']+'_reg_clear    ('+entry['name']+'_reg_clear),\n')
     if entry['type']=="RWS" :
       moduleFile.write('   .'+entry['name']+'_reg          ('+entry['name']+'_reg),\n')
     if entry['type']=="WO" :
       moduleFile.write('   .'+entry['name']+'_reg          ('+entry['name']+'_reg),\n')
     if entry['type']=="WOE" :
       moduleFile.write('   .'+entry['name']+'_reg          ('+entry['name']+'_reg),\n')
     if entry['type']=="RWA" :
       moduleFile.write('   .ip2cpu_'+entry['name']+'_reg          (ip2cpu_'+entry['name']+'_reg),\n')
       moduleFile.write('   .cpu2ip_'+entry['name']+'_reg          (cpu2ip_'+entry['name']+'_reg),\n')
     if entry['type']=="RWCR" :
       moduleFile.write('   .ip2cpu_'+entry['name']+'_reg          (ip2cpu_'+entry['name']+'_reg),\n')
       moduleFile.write('   .cpu2ip_'+entry['name']+'_reg          (cpu2ip_'+entry['name']+'_reg),\n')
       moduleFile.write('   .cpu2ip_'+entry['name']+'_reg_clear    (cpu2ip_'+entry['name']+'_reg_clear),\n')
     if entry['type']=="RWCW" :
       moduleFile.write('   .ip2cpu_'+entry['name']+'_reg          (ip2cpu_'+entry['name']+'_reg),\n')
       moduleFile.write('   .cpu2ip_'+entry['name']+'_reg          (cpu2ip_'+entry['name']+'_reg),\n')
       moduleFile.write('   .cpu2ip_'+entry['name']+'_reg_clear    (cpu2ip_'+entry['name']+'_reg_clear),\n')

  moduleFile.write('   // Global Registers - user can select if to use\n\
   .cpu_resetn_soft(),//software reset, after cpu module\n\
   .resetn_soft    (),//software reset to cpu module (from central reset management)\n\
   .resetn_sync    (resetn_sync)//synchronized reset, use for better timing\n\
);\n\
//registers logic, current logic is just a placeholder for initial compil, required to be changed by the user\n');

#registers logic

  moduleFile.write('always @(posedge axi_aclk)\n\
	if (~resetn_sync) begin\n');

  for entry in regsDict:
     if entry['type']=="RO"  :
       moduleFile.write('		'+entry['name']+'_reg <= #1    `REG_'+entry['name'].upper()+'_DEFAULT;\n')
     if entry['type']=="ROC" :
       moduleFile.write('		'+entry['name']+'_reg <= #1    `REG_'+entry['name'].upper()+'_DEFAULT;\n')
     if entry['type']=="RWA" :
       moduleFile.write('		ip2cpu_'+entry['name']+'_reg <= #1    `REG_'+entry['name'].upper()+'_DEFAULT;\n')
     if entry['type']=="RWCR" :
       moduleFile.write('		ip2cpu_'+entry['name']+'_reg <= #1    `REG_'+entry['name'].upper()+'_DEFAULT;\n')
     if entry['type']=="RWCW" :
       moduleFile.write('		ip2cpu_'+entry['name']+'_reg <= #1    `REG_'+entry['name'].upper()+'_DEFAULT;\n')
       moduleFile.write('		cpu_'+entry['name']+'_reg_clear_d <= #1    \'h0\n;')
      
  moduleFile.write('	end\n\
	else begin\n')
  for entry in regsDict:
     if entry['type']=="RO"  :
       moduleFile.write('		'+entry['name']+'_reg <= #1    `REG_'+entry['name'].upper()+'_DEFAULT;\n')
     if entry['type']=="ROC" :
       moduleFile.write('		'+entry['name']+'_reg <= #1  '+entry['name']+'_reg_clear ? \'h0  : `REG_'+entry['name'].upper()+'_DEFAULT;\n')
     if entry['type']=="RWA" :
       moduleFile.write('		ip2cpu_'+entry['name']+'_reg <= #1    `REG_'+entry['name'].upper()+'_DEFAULT;\n')
     if entry['type']=="RWCR" :
       moduleFile.write('		ip2cpu_'+entry['name']+'_reg <= #1  '+entry['name']+'_reg_clear ? \'h0  : `REG_'+entry['name'].upper()+'_DEFAULT;\n')
     if entry['type']=="RWCW" :
       moduleFile.write('		ip2cpu_'+entry['name']+'_reg <= #1  '+entry['name']+'_reg_clear_d ? \'h0  :    `REG_'+entry['name'].upper()+'_DEFAULT;\n')
       moduleFile.write('		cpu_'+entry['name']+'_reg_clear_d <= #1    cpu_'+entry['name']+'_reg_clear;\n')

  moduleFile.write('        end\n\n')



#end of write_module_template

########################################################################################
#
# Main function body
#
########################################################################################


# List of files to be generated.
filename_regs='cpu_regs.v'
filename_defs='cpu_regs_defines.v'
filename_template='module_cpu_template.v'
filename_mpd='module_name.mpd' 
filename_tcl='module_name.tcl' 

# Open the files for writing
regsFile = open(filename_regs, 'w')
defsFile = open(filename_defs, 'w')
moduleFile = open(filename_template, 'w')
mpdFile = open(filename_mpd, 'w')
tclFile = open(filename_tcl, 'w')

# Write the header of each file
write_regs_header(regsFile)
write_defs_header(defsFile)
write_tcl_header(tclFile)

#Write the regs module
#first the ports...
regsDict=create_regs_list()
write_regs_ports(regsFile,regsDict)

#then the wires...
write_regs_wires(regsFile,regsDict)

#instantiate sub modules...
instantiate_submodules(regsFile)
   
#resets etc.....
sync_reset(regsFile)

#ipif ACK signals
ack_ipif(regsFile)

#registers logic...
write_logic(regsFile,regsDict)

#indirect access...

#tables...

#close module.....
regsFile.write('endmodule\n')

#write the defs module
write_defines(defsFile,regsDict)

#write the tcl module
write_tcl(tclFile,regsDict)

#write the default text to be copied to the mpd module
write_mpd(mpdFile,regsDict)

#writes the default text to be copied to the top module
write_module_template(moduleFile,regsDict)


# Close the output files
regsFile.close()
defsFile.close()
tclFile.close()
moduleFile.close()
mpdFile.close()

